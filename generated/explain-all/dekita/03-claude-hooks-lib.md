# .claude/hooks/lib ライブラリ

フック実装の共通機能を提供するライブラリモジュール。

## ファイル一覧（31個）

| ファイル名 | Why（なぜ必要か） | What（何をするか） | 使い方 |
|------------|------------------|-------------------|--------|
| `__init__.py` | フックから共通機能への一貫したアクセスを提供し、サブモジュールの構成を隠蔽してAPIを安定化させるため | 定数、cwd、git、github、logging、stringsのサブモジュールから主要な関数・クラスを再エクスポートする統一エントリポイント | `from lib import get_effective_cwd, get_current_branch` または `from lib.cwd import get_effective_cwd` |
| `block_patterns.py` | フックの有効性を分析し、ブロック後の解決パターンから学習するためにblock→success追跡が必要 | record_block()でブロックイベントを記録、check_block_resolution()で成功時に先行ブロックと照合、60秒以内の解決をblock_resolved、超過をblock_expiredとして記録 | `record_block(hook_name, reason, details, session_id)` でブロック記録、`check_block_resolution(hook_name, details, session_id)` で解決確認 |
| `command_parser.py` | 開発ワークフロー分析のため、コマンドを構造化データに変換し、操作種別・引数・結果を追跡可能にする | parse_command()でコマンド文字列を構造化dictに変換、extract_result_from_output()でstdout/stderrから結果を抽出、is_target_command()でログ対象コマンドか判定 | `parsed = parse_command("gh pr create")` で構造化データ取得、`result = extract_result_from_output(parsed, stdout, stderr)` で結果抽出 |
| `command_utils.py` | command_parser.pyとgithub.py間の循環インポートを解消し、共通のコマンド処理ロジックを一箇所に集約するため | get_command_name()でパス付きコマンドからコマンド名抽出、normalize_shell_separators()でシェル区切り文字を正規化、is_command_wrapper()でsudo/time等のラッパー判定 | `get_command_name("/usr/bin/git")` → `"git"`、`normalize_shell_separators("echo foo;git status")` → `"echo foo ; git status"` |
| `constants.py` | 複数のフックで使用する定数を一箇所で管理し、循環インポートを防止するため | タイムアウト定数（TIMEOUT_LIGHT/MEDIUM/HEAVY）、ログローテーション設定、セッションマーカー設定、ログレベル分離設定を定義 | `from lib.constants import TIMEOUT_MEDIUM, LOG_MAX_SIZE_BYTES, SESSION_MARKER_FILE` |
| `cwd.py` | cdコマンド実行後のworktree削除を正しくブロックするため、複数ソースからの効果的なcwd検出が必要 | get_effective_cwd()で環境変数・コマンド内cdを考慮したcwd取得、check_cwd_inside_path()でcwdが指定パス内にあるか判定、extract_cd_target_from_command()でコマンド内cdターゲット抽出 | `cwd = get_effective_cwd(command)` で実効cwd取得、`if check_cwd_inside_path(worktree_path, command): block_deletion()` |
| `execution.py` | フック実行の追跡・分析のため、構造化されたログ記録が必要 | log_hook_execution()でフック実行をJSONL形式で記録、rotate_log_if_needed()でログファイルのサイズベースローテーション、compress_rotated_logs()でローテート済みログのgzip圧縮 | `log_hook_execution("my-hook", "approve", reason="OK", session_id=ctx.get_session_id())` |
| `flow.py` | ワークフローの進捗を追跡し、フローの完了状況を可視化するため | start_flow()でフローインスタンス開始、complete_flow_step()でステップ完了記録、complete_flow()でフロー完了記録、get_flow_status()でフロー状態取得 | `instance_id = start_flow(flow_log_dir, "issue-ai-review", context, session_id)` → `complete_flow_step(flow_log_dir, instance_id, "review", session_id=session_id)` |
| `git.py` | ブランチ、コミット、worktree操作で共通して必要なgit操作を一元化し、各フックでの重複実装を防ぐ | get_current_branch()で現在のブランチ名取得、get_head_commit()でHEADコミットハッシュ取得、get_diff_hash()で差分のハッシュ取得、check_recent_commits()で直近コミットの有無確認 | `branch = get_current_branch()`、`has_recent, info = check_recent_commits(worktree_path)` |
| `github.py` | gh CLIコマンドのパース・実行・結果解析を一元化し、各フックでの重複実装とバグを防ぐ | parse_gh_pr_command()でgh prコマンドからサブコマンド・PR番号抽出、get_pr_number_for_branch()でブランチからPR番号取得、is_pr_merged()でPRのマージ済み判定 | `subcmd, pr_num = parse_gh_pr_command("gh pr merge 123")`、`if is_pr_merged(pr_number): skip_check()` |
| `hook_input.py` | PostToolUseフックでツール実行結果へのアクセスを標準化し、フィールド名の不一致（tool_result/tool_response/tool_output）を吸収する | get_exit_code()でtool_resultからexit_codeを一貫した方法で取得、get_tool_result()で複数フィールド名に対応したツール結果取得 | `tool_result = get_tool_result(hook_input)`、`exit_code = get_exit_code(tool_result)` |
| `input_context.py` | ログ・分析のため、フック入力から一貫した形式でコンテキスト情報（ツール名、プレビュー）を抽出する | extract_input_context()でフック入力からコンテキストを抽出、merge_details_with_context()でdetailsとコンテキストをマージ | `context = extract_input_context(input_data)`、`merged = merge_details_with_context(details, context)` |
| `issue_dependency.py` | 複数セッション並行作業時のコンフリクトを防ぐため、ファイル重複に基づくIssue間依存関係を検出する | build_dependency_graph()でworktreeからファイル重複で依存グラフ構築、find_independent_issues()でアクティブIssueと競合しないIssueを検出、suggest_independent_issues()で着手可能なIssueを優先度順で提案 | `graph = build_dependency_graph(worktree_infos)`、`independent = find_independent_issues(graph, active_issues)` |
| `labels.py` | Issue/PR作成時のラベル検証・優先度チェックのため、コマンドからラベルを正確に抽出する必要がある | extract_labels_from_command()で--labelオプションからラベル抽出、has_priority_label()でP0-P3優先度ラベルの有無を判定、suggest_labels_from_text()でタイトル/本文からラベルを提案 | `labels = extract_labels_from_command("gh issue create --label bug --label P1")`、`has_priority = has_priority_label(labels)` |
| `logging.py` | ログの可視化改善とデバッグ支援のため、レベル別ログ出力とエラー発生時のコンテキスト（前後の操作）キャプチャが必要 | get_log_level()で決定値からログレベル判定、log_to_level_file()でレベル別ファイルへのログ出力、log_to_session_file()でセッション固有ファイルへのログ出力、ErrorContextManagerでエラー前後のコンテキスト管理 | `log_to_session_file(log_dir, "flow-progress", session_id, entry)`、`error_context_manager.add_entry(session_id, log_entry)` |
| `path_validation.py` | 外部入力（transcript path）のパストラバーサル攻撃を防止し、許可されたディレクトリのみへのアクセスを保証する | is_safe_transcript_path()でtranscriptパスの安全性検証（許可ディレクトリ: ホーム、システムtemp、cwd） | `if is_safe_transcript_path(path_str): process_transcript(path_str)` |
| `repo.py` | worktreeのルート検出やマージ成功判定、リポジトリ操作で共通して必要な機能を一元化する | get_repo_root()でworktreeを考慮したリポジトリルート取得、is_merge_success()でgh pr mergeの成功判定（--delete-branchオプション使用時の特殊処理含む） | `repo_root = get_repo_root()`、`if is_merge_success(exit_code, stdout, command): log_merge()` |
| `research.py` | PR作成前のリサーチ・コード探索が十分か判定するため、WebSearch/WebFetch/Read/Glob/Grepの使用状況を追跡する | check_research_done()でリサーチ実施有無を判定、get_exploration_depth()で探索深度（Read/Glob/Grep回数）を取得、get_research_summary()でリサーチ活動のサマリーを取得 | `if check_research_done(session_dir, session_id): allow_pr_creation()`、`depth = get_exploration_depth(session_dir, session_id)` |
| `results.py` | フック結果の形式を統一し、ブロック時のメッセージ表示・ログ記録・連続ブロック検出を一元化する | make_block_result()でブロック結果生成（ログ自動記録、連続ブロック警告）、make_approve_result()で承認結果生成、check_skip_env()でSKIP_*環境変数チェック | `return make_block_result("my-hook", "Block reason", ctx=ctx)` または `return make_approve_result("my-hook", "OK")` |
| `review.py` | レビューコメントの対応状況・品質を追跡し、重複コメント検出・カテゴリ分類で効率的なレビュー対応を支援する | log_review_comment()でレビューコメントをログに記録、log_codex_review_execution()でCodex CLI実行をログに記録、find_similar_comments()で類似コメントを検出（重複防止） | `log_review_comment(metrics_log_dir, pr_number, comment_id, "copilot", category="bug")`、`similar = find_similar_comments(new_comment, previous_comments)` |
| `session.py` | セッション単位でログをグループ化し、状態を追跡するためにセッションID管理機能が必要 | HookContextで依存性注入パターンによるセッション情報管理、parse_hook_input()でstdinからフック入力をパース、is_fork_session()でfork-session検出 | `hook_input = parse_hook_input()`、`ctx = create_hook_context(hook_input)`、`session_id = ctx.get_session_id()` |
| `session_graph.py` | 複数セッション間の関係（親子・兄弟）とworktree所有関係を把握し、競合を避けた並行作業を可能にする | get_worktree_session_map()でworktreeとセッションIDのマッピング取得、get_sibling_sessions()で兄弟セッション（共通祖先を持つ）を検出、get_active_worktree_sessions()でworktreeを関係性でグループ化 | `worktree_map = get_worktree_session_map()`、`siblings = get_sibling_sessions(current_session_id, transcript_path)` |
| `session_validation.py` | セッションIDをファイルパスに使用する際のパストラバーサル攻撃を防止し、UUID/英数字ハッシュ形式のみを許可する | is_safe_session_id()でセッションIDの安全性検証（許可文字: 英数字とハイフンのみ） | `if is_safe_session_id(session_id): use_in_path(session_id)` |
| `strings.py` | コマンドパース、ブランチ名サニタイズ、環境変数抽出、外部依存なしの文字列操作を一箇所に集約する | strip_quoted_strings()でクォート内文字列を除去、split_command_chain()でコマンドチェーンを分割、sanitize_branch_name()でブランチ名をファイル名用にサニタイズ | `stripped = strip_quoted_strings(cmd)`、`commands = split_command_chain(stripped)`、`safe_name = sanitize_branch_name(branch)` |
| `timing.py` | フックのパフォーマンス分析のため、実行時間を自動計測し、ログに記録する仕組みを提供する | HookTimerクラスで手動タイミング計測、timed_hook()デコレータで自動タイミング計測（SystemExit/例外時も計測結果をログ出力） | `@timed_hook("my-hook")` でデコレータ使用、または `timer = HookTimer("my-hook")` → `elapsed = timer.elapsed_ms()` |
| `timestamp.py` | ログ記録・トラッキングで一貫したタイムスタンプ形式を使用するため | get_local_timestamp()でローカルタイムゾーンでISO形式取得、parse_iso_timestamp()でISO 8601文字列をdatetimeにパース、generate_timestamp_id()でタイムスタンプベースの一意ID生成 | `ts = get_local_timestamp()`、`dt = parse_iso_timestamp("2025-12-16T12:00:00Z")`、`id = generate_timestamp_id("blk")` |
| `transcript.py` | トランスクリプト処理ロジックを複数フックで重複実装しないため | is_in_code_block()でコードブロック内判定、extract_assistant_responses()でassistant応答テキスト抽出、load_transcript()でJSON/JSONL両形式のトランスクリプト読み込み | `responses = extract_assistant_responses(content)`、`transcript = load_transcript(transcript_path)` |
| `parsers/__init__.py` | コマンドパーサーをサブモジュールとして整理し、モジュール性を向上させるため | gh_parser、git_parser、npm_parserから主要な関数（parse_gh_command, parse_git_command, parse_npm_command）を再エクスポート | `from lib.parsers import parse_gh_command, parse_git_command, extract_conflict_info` |
| `parsers/gh_parser.py` | gh CLIコマンドの構造化パースを詳細なログ記録と開発ワークフロー分析のために提供する | parse_gh_command()でgh CLIコマンドを構造化データにパース（gh pr, gh issue, gh api, gh run, gh auth対応） | `parsed = parse_gh_command("gh pr create --title test")`、`parsed["operation"]` → `"pr_create"` |
| `parsers/git_parser.py` | gitコマンドの構造化パースを詳細なログ記録と開発ワークフロー分析のために提供する | parse_git_command()でgitコマンドを構造化データにパース、extract_worktree_add_path()でworktreeパス抽出、extract_conflict_info()でコンフリクト情報抽出 | `parsed = parse_git_command("git push origin main")`、`path = extract_worktree_add_path("git worktree add .worktrees/foo")` |
| `parsers/npm_parser.py` | npm/pnpmコマンドの構造化パースを詳細なログ記録と開発ワークフロー分析のために提供する | parse_npm_command()でnpm/pnpmコマンドを構造化データにパース（run, install, test, build等のサブコマンド対応） | `parsed = parse_npm_command("npm run test")`、`parsed["operation"]` → `"run_test"` |

## テストディレクトリ

| ディレクトリ | ファイル数 | 実行コマンド |
|-------------|-----------|--------------|
| `.claude/hooks/tests/` | 227個 | `pytest .claude/hooks/tests/` |
