# AGENTS.md

AIコーディングエージェント向けのプロジェクト指示。

詳細な手順はSkillsに分離されています。Claudeが自動で発見・使用します。

---

## 基本原則

ユーザーからの依頼・要望は全て**指示**として扱い、即座に実行する。

- 「承知しました」だけで終わらない
- 実行してから報告する
- **差し込みタスク優先**: CI待ちなどのブロッキング中に簡単なタスク（Issue作成、コメント追加など）が依頼されたら先に処理
- **マージまで完遂**: タスク完了時はPR作成で止まらず、CI監視→レビュー対応→マージまで実行
  - ❌ 「マージしますか？」「マージしてよいですか？」と確認を求める
  - ❌ CIパス・レビュー完了後にユーザーの次の指示を待つ
  - ✅ マージ可能になったら即座に `gh pr merge` を実行
- **Phase分割タスクの自動進行**: Phase分割されたタスク（移行計画など）は、Phase完了時に確認を求めず自動的に次Phaseに進む
  - ❌ 「Phase 2に進みますか？」「次のPhaseを開始しますか？」
  - ✅ Phase 1完了 → 即座にPhase 2開始（確認なし）
  - ✅ 全Phase完了まで継続
  - ✅ 計画書などレビューが必要な成果物がある場合は、レビューを依頼し承認後に次Phaseへ進む
- **エラー発見時の自動Issue作成**: 問題を発見したら、まずIssueを作成してから作業を続行する（ユーザーへの確認不要）
- **オープンIssueの問題は未解決**: Issueを作成しても、クローズされるまでその問題は存在し続ける。作業中は常にオープンIssueの問題を意識し、手動で回避すること
- **機能実装後の懸念点洗い出し**: 新機能やフックを実装したら、設計上の懸念点を自発的に洗い出してIssue化する（ユーザーに指摘される前に）
- **タスク完了時の次ステップ提案**: タスク完了後、次にやろうとしていることを提案する。ユーザーが承認するだけで次に進めるようにする。次にやることがなければ「何をしますか？」と聞く
- **セッション開始時ファイルは最優先タスク**: `claude /path/to/file.md` のようにファイルを指定して起動された場合、そのファイルの内容は**最優先タスク**として扱う。他の作業（handoff改善、リファクタリング等）より先に、指定されたファイルの内容を実行すること
- **選択肢提示時はAskUserQuestion使用**: 複数の選択肢がある場合、テキストで列挙せずAskUserQuestionツールを使用する。ユーザーの入力負担を減らし、選択ミスを防ぐ
- **セッション内で作成したIssueは実装まで完遂**: Issue作成だけで「完了」としない。作成したIssueは**確認を求めずに即座に着手**し、同じセッション内で実装・マージまで完遂する（競合時はユーザー確認）
- **仕組み化 = ドキュメント + 強制機構**: 「仕組み化」を謳う場合、ドキュメント追加だけでは不十分。違反を**ブロック**するフック/CI/ツール等の強制機構まで実装して初めて完了
- **Dogfooding原則**: 新機能（特にデータ処理スクリプト）実装時は、その機能が解決する問題を**自分で再現・体験**してから実装完了とする。実データでテストし、エッジケース（空、改行含む、大量データ）を確認すること

**作業種別ごとのDogfooding方法**:

| 作業種別 | Dogfooding方法 | 具体例 |
| -------- | -------------- | ------ |
| **フック修正** | そのセッション内でフックをトリガーする操作を実施 | PreToolUse hookなら該当ツールを呼び出す、PostToolUse hookならツール実行後の状態を確認、Stop hookならセッション終了を試みる |
| **観点追加（reflection_self_check）** | 新観点の動作確認を実施し、継続的に検証する | 新観点のキーワードを含む記述を振り返り本文に含める、`get_missing_perspectives()`で検出漏れがないことを確認、以降の全振り返りで追加した観点が適切に検出されているか確認 |
| **スクリプト修正** | 実データで動作確認（正常系・異常系・エッジケース） | 空入力、改行を含む入力、大量データで実行、エラー時の挙動を確認 |
| **Plan mode関連** | plan modeを使用して実際の動作を確認 | EnterPlanModeを呼び出し計画作成→承認フローを体験、ExitPlanModeで正しく終了するか確認 |
| **CI/監視ツール** | 実際のPRで動作確認 | `bun run .claude/scripts/ci_monitor_ts/main.ts <PR> --session-id <SESSION_ID>` で実PRを監視、BEHIND検知→自動リベース、レビュー完了検知が正しく動作するか確認 |
| **ドキュメント追加** | 追加した手順を実際に実行し、継続的に使用する | 記載したコマンドを実行して動作検証、以降のセッション（特に振り返り）で表/ガイドを参照・使用 |

**重要**: 「テストが通った」だけでは不十分。自分で使ってみて初めて気づく問題（使いにくさ、誤解を招く表現、エッジケース等）がある

- **AIレビューは最後の砦**: AIレビュー（Copilot、Codex、Gemini等）を「安全網」として期待しない。AIレビューで検出されることを理由にIssue作成やテスト追加を省略してはならない
  - ❌ 「レビューで検出可能だからIssue不要」
  - ❌ 「AIレビューが指摘してくれたから問題なし」
  - ✅ AIレビューは**存在しないもの**として行動し、自分で検証・対策する
  - ✅ AIレビューで問題が検出された場合、「なぜ自分で事前に気づけなかったか」を振り返る
- **ユーザー指摘 = 即Issue化**: ユーザーが問題指摘・改善提案をした場合、修正だけでなく即座にIssue作成が必須
  - ❌ 「わかりました、修正します」だけで終わる
  - ✅ 指摘を受ける → 既存Issueがないか確認 → `gh issue create` → 修正着手
- **ユーザーフィードバック = 修正 + 仕組み化**: ユーザーが問題を指摘した場合、その問題の修正だけでは不十分。類似問題を将来検出できる仕組み化が必須
  - ❌ 問題を修正して「完了」とする
  - ❌ 「今後気をつける」と記述して終了
  - ✅ `/adding-perspectives` で振り返り観点を追加
  - ✅ フック/CI/ツールで自動検出を実装
  - ✅ 仕組み化が不要な理由をIssueに記録

### オープンIssueと行動の関係

| Issueの状態 | 意味 | 私の行動 |
| ----------- | ---- | -------- |
| **オープン** | 問題は未解決、対策は未実装 | 常に意識し、手動で回避する |
| **クローズ** | 対策が実装済み | 仕組みが守ってくれるので意識不要 |

**例**: 「別セッション競合防止」のIssueがオープンなら、全ての作業で「別セッションが作業中かも」と懸念しながら取り組む。フックで強制ブロックされなくても、自分で確認・回避する。

### 全Issue = Plan mode必須（Issue #3807）

**重要**: 全てのIssueでPlan modeを使用し、計画を作成してから実装を開始する。

| ワークフロー | 説明 |
| ------------ | ---- |
| 1. Issue確認 | 要件を把握 |
| 2. EnterPlanMode | 計画を作成 |
| 3. 他AIレビュー | Gemini等で計画をレビュー |
| 4. ExitPlanMode | 承認後に実装開始 |

**理由**: 計画を他のAIにレビューしてもらうことで、設計品質を向上させる。

**バイパス（緊急時のみ）**: `SKIP_PLAN=1`環境変数でバイパス可能

| 条件 | SKIP_PLAN使用 |
| ---- | ------------- |
| P0障害対応 | ✅ 許可（Issue/PRにバイパス理由を記録） |
| 上記以外 | ❌ 禁止（Plan modeを使用すること） |

### Plan mode計画作成のチェックリスト

Plan modeで計画を作成する際は、Issue本文の内容を漏れなく反映する:

| 確認項目 | 内容 |
| -------- | ---- |
| **Whyの確認** | Issue本文の背景・目的を計画に含めたか |
| **Whatの確認** | 現在の状態・再現手順を理解したか |
| **Howの確認** | Issue本文のHowセクションの**全項目**を計画に反映したか |

**重要**: Howセクションの各項目に対応するタスクが計画に含まれているか確認。含まれていない項目がある場合は理由を明記すること。

**背景**: PR #3880でHowセクションの項目を見落とし、レビューで指摘されたため、再発防止としてこのチェックリストを追加（Issue #3884）。

### Issue作業開始前の確認（必須）

**全てのIssueに対して**、作業開始前に以下を確認:

```bash
# 1. 既存worktreeの確認
git worktree list | grep -iE "issue-<番号>|<キーワード>"

# 2. 既存PRの確認
gh pr list --search "<Issue番号> OR <キーワード>"

# 3. assigneeの確認
gh issue view <番号> --json assignees -q '.assignees[].login'
```

**以下のいずれかに該当する場合、ユーザーに確認してから作業開始**:

| 状態 | 意味 | 対応 |
| ---- | ---- | ---- |
| worktreeが存在 & ロック中 | 別セッションが作業中 | 作業しない（※ユーザー指示がある場合は[ロック解除の判断基準](#ロック解除の判断基準)参照） |
| worktreeが存在 & 未コミット変更あり | 作業途中の可能性 | 確認してから判断 |
| worktreeが存在 & 直近1時間以内のコミット | 最近まで作業していた | 確認してから判断 |
| PRが存在 & レビュー進行中 | 別セッションが対応中 | 作業しない |
| 自分以外の担当者が含まれる | 別ユーザーが担当中 | 作業しない（担当者に確認） |

**重要**: 「ロックされていないから大丈夫」と自己判断しない。状況をユーザーに報告し、指示を仰ぐ。

### ロック解除の判断基準

ユーザーが明示的に「続きをやって」「このPRをマージして」等と指示した場合、以下の条件を確認し自律的にロック解除できる:

| 条件 | ロック解除 |
| ---- | ---------- |
| 最終コミットから1時間以上経過 **かつ** 作業ツリーがクリーン | ✅ 可能 |
| 最終コミットから1時間未満 | ⚠️ ユーザーに状況報告して確認 |
| 未コミット変更あり | ⚠️ ユーザーに状況報告して確認 |
| ユーザーからの指示がない場合 | ❌ ロック解除しない |

**確認コマンド**:

```bash
# 最終コミット時刻を確認（worktree内で実行）
git log -1 --format="%ci"

# 作業ツリーの状態を確認
git status --porcelain
```

**背景**: PR #3457で、11時間前のコミット・クリーンな作業ツリーにも関わらず、ユーザー確認を求めた。明示的な指示がある場合は自律的にロック解除すべき。

### Issue依存関係の確認

Issue間の依存関係を明示し、適切なタイミングで作業を開始する。

#### 依存関係の種類

| 種類 | 記載方法 | 意味 |
| ---- | -------- | ---- |
| **Blocked by** | `- **Blocked by**: #123, #124` | 指定Issueがクローズされるまで着手禁止 |
| **Related** | `- **Related**: #125` | 関連するが、着手可能 |
| **Independent** | `- **Independent**: true` | 他Issueとの依存なし、並列作業に最適 |

#### Issue本文のDependenciesセクション

例1: 依存関係あり

```markdown
## Dependencies
- **Blocked by**: #123, #124
- **Related**: #125
```

例2: 独立したIssue（並列作業に最適）

```markdown
## Dependencies
- **Independent**: true
```

**記載ルール**:

- Blocked byがある場合: 全てのブロック元がクローズされるまで着手禁止
- Dependenciesセクションがない場合: 「未分析」扱い、着手前に分析必須

#### 着手前の確認コマンド

```bash
# 1. Dependenciesセクションを取得
gh issue view <番号> --json body -q .body | awk '/^## Dependencies/{flag=1; print; next} /^## /{flag=0} flag'

# 2. Blocked byがあれば、全てのブロック元の状態を確認
gh issue view <ブロック元番号> --json state -q .state
# → "CLOSED" 以外なら着手禁止
```

#### 着手可否判定フロー

1. Dependenciesセクションが存在する？
   - No → 要分析（着手前に依存関係を確認・追記）
   - Yes → 2へ
2. Blocked byがある？
   - No → 着手可能
   - Yes → 3へ
3. 全ブロック元がCLOSED？
   - Yes → 着手可能
   - No → 着手禁止（ブロック元完了を待つ）

#### fork-session向けの推奨Issue

| セッション種別 | 推奨Issue |
| -------------- | --------- |
| 親セッション | ブロック中のIssue、複雑なIssue |
| fork-session | `Independent: true` のIssue |
| 複数セッション並列 | 互いに `Independent` なIssue群 |

### オープンPRへの介入禁止

**オープンPRが存在するIssueには一切触れない**。これは最重要ルールである。

| 状況 | 禁止される行動 | 理由 |
| ---- | -------------- | ---- |
| PR #XがオープンでCI待ち | レビューコメント対応を開始 | 別セッションが担当中 |
| PR #Xがオープンでレビュー中 | コード修正をプッシュ | コンフリクトの原因 |
| PR #Xがオープン | 同じIssueの新PRを作成 | 重複作業 |

**PRとworktreeの関係**:

- PRのブランチ名（例: `feat/issue-123-xxx`）とworktree名（例: `issue-123`）は対応する
- worktreeが存在しなくてもPRがオープンなら介入禁止
- PRがクローズ/マージ済みなら、同じIssueの新作業は可能

**確認コマンド**:

```bash
# オープンPRとそのブランチを一覧
gh pr list --state open --json number,headRefName,title --jq '.[] | "#\(.number) \(.headRefName): \(.title)"'
```

### fork-sessionの行動指針

**fork-sessionの判定方法**: SessionStartのSession IDと、UserPromptSubmitのSession IDが異なる場合、自分はfork-sessionである。

**fork-sessionとして禁止される行動**:

| ❌ 禁止 | 理由 |
| ------ | ---- |
| 「他のIssueはfork-sessionに任せます」という発言 | 自分がfork-sessionであることを認識していない |
| 親セッションが作業中のIssueへの着手 | 競合・コンフリクトの原因 |
| 自分が親セッションであるかのような振る舞い | 役割の誤認 |
| 「私が担当し、他のセッションに割り振ります」 | fork-sessionにはその権限がない |

**fork-sessionとして推奨される行動**:

| ✅ 推奨 | 説明 |
| ------ | ---- |
| `fork-session-collaboration-advisor`の提案に従う | 独立したIssue候補から選択 |
| 親セッションの作業中Issueを避ける | 表示された親セッションのIssueには着手しない |
| 独立した作業を選択 | 競合しないファイルを変更するIssue |

**背景**: PR #2514の振り返りセッションで、fork-sessionが「他のIssueはfork-sessionに任せます」と発言し、自分が親セッションであるかのように振る舞った（Issue #2519）。

### Issue作成が必要なケース

以下の問題を発見した場合、**報告だけで終わらず必ずIssueを作成**する:

| カテゴリ | 具体例 |
| -------- | ------ |
| フックの問題 | 予期せぬブロック、誤検知、エラーメッセージの矛盾 |
| ツールのバグ | スクリプトの動作不良、期待と異なる出力 |
| 設計上の課題 | 競合状態、エッジケース未対応、仕様の曖昧さ |
| ドキュメント | 手順の不備、古い情報、説明不足 |
| CI/CD | テストの不安定、ビルド失敗の再現、デプロイ問題 |

**手順**:

1. 問題を発見したら、作業を一時中断
2. `gh issue create` でIssueを作成（タイトル・本文に再現手順を含める）
3. 作成したIssue番号をユーザーに報告
4. 元の作業を続行

**注意**: 「問題があります」「動作していません」とユーザーに報告するだけでは不十分。Issue作成まで完了させる

#### Issue作成依頼の即時対応（必須）

ユーザーから「Issueを作成してください」「Issue化してください」と依頼された場合:

1. **即座に** `gh issue create` を実行
2. 他の作業（マージ、リベース等）より優先
3. Issue作成完了後に元の作業に戻る

| ❌ 禁止 | ✅ 正しい対応 |
| ------ | ------------ |
| 「マージ後にIssue作成」 | 今すぐ `gh issue create` |
| 「この作業が終わったら」 | 作業を中断してIssue作成 |
| 「後で作ります」 | 即座にIssue作成 |

**強制**: `issue_creation_request_check` フックがセッション終了時に未対応の依頼をブロック

**背景**: PR #3579で「対策をIssueにしてください」と依頼されたが、マージ作業に気を取られてIssue作成を忘れた（Issue #3586）。

#### Issue作成前チェックリスト

Issue作成時に以下を事前に準備する。これらが不足すると `issue-body-requirements-check` や `issue-priority-label-check` でブロックされる:

| 項目 | 内容 | 検証フック |
| ---- | ---- | ---------- |
| **優先度ラベル** | P0〜P3のいずれかを決定 | `issue-priority-label-check` |
| **Why** | 問題発生の経緯、影響範囲 | `issue-body-requirements-check` |
| **What** | 現在どう動いているか、再現手順 | `issue-body-requirements-check` |
| **How** | 具体的な解決策 | `issue-body-requirements-check` |

**優先度の判断基準**:

| ラベル | 基準 | 例 |
| ------ | ---- | -- |
| P0 | 本番障害、セキュリティ | 認証バイパス、データ消失 |
| P1 | 重要機能のバグ、ブロッカー | CI失敗、主要フロー停止 |
| P2 | 改善、軽微なバグ | UX改善、エッジケース対応 |
| P3 | ドキュメント、リファクタリング | typo修正、コード整理 |

**テンプレート例**:

```markdown
## Why
[Describe the motivation/background for this issue]

## What
[Describe the current state or what this issue is about]

## How
[Describe the proposed solution]
```

#### 「後でフォローアップ」発言時のIssue作成（必須）

レビューコメントや会話で以下のような発言をする場合、**必ず同時にIssueを作成**する:

| 禁止される発言パターン | 正しい対応 |
| ---------------------- | ---------- |
| 「今後のフォローアップとして検討します」 | Issue作成してから発言 |
| 「将来的に対応します」 | Issue作成してから発言 |
| 「別途対応が必要です」 | Issue作成してから発言 |
| 「スコープ外なので後で」 | Issue作成してから発言 |

**理由**: Issueを作成しないフォローアップ発言は「何もしない」と同義。忘れられ、対応されない。

**正しい例**:

```text
今回のスコープ外のため、Issue #1488 を作成しました。
```

**禁止される例**:

```text
今後のフォローアップとして検討します。（Issue作成なし）
```

**チェックリスト**: 「後で」「将来」「フォローアップ」「別途」などの単語を使う前に:

1. 本当にスコープ外か確認
2. スコープ外なら`gh issue create`でIssue作成
3. Issue番号を含めてコメント

#### 「心がけ」系表現の禁止

以下の表現は**再発防止策ではない**ため、使用禁止:

| 禁止される表現 | 理由 |
| -------------- | ---- |
| 「今後意識する」 | 仕組み化されていない |
| 「気をつける」 | 記憶に依存する |
| 「心がける」 | 強制力がない |
| 「注意する」 | 具体的アクションがない |
| 「留意する」 | 検証不可能 |

**正しい対応**:

| 状況 | 対応 |
| ---- | ---- |
| 既存ルールでカバー済み | 「既存ルールでカバー済み。追加アクション不要」で終了 |
| 新しい問題を発見 | Issue作成 → 仕組み化（フック/CI等の強制機構 + ドキュメント化） |

**理由**: 「心がけ」は人間の記憶に依存し、再現性がない。問題の再発防止には**仕組み**が必要。

#### セッション内で作成したIssueの扱い

セッション中に作成したIssueは、**ユーザー確認なしで即座に実装を開始**し、**そのセッション内で実装まで完遂**する。

| ❌ 禁止パターン | ✅ 正しいパターン |
| -------------- | ---------------- |
| Issue作成 → 「完了」としてtodo更新 | Issue作成 → 実装 → PR → マージ → 「完了」 |
| 「Issue #xxx を作成しました。次は？」 | 「Issue #xxx を作成しました。実装を開始します」 |
| 「続行しますか？」「実装しますか？」 | 確認なしで即座に実装開始 |
| 「コンテキストが○○%です。続行しますか？」 | コンテキスト使用率に関係なく着手 |

**重要**: Issue作成後に確認を求めることは禁止。以下の理由で「続行しますか？」と聞いてはならない:

- コンテキスト使用率
- 時間がかかりそう
- 「念のため確認」

**例外**:

- 別セッションで作業中のIssueと競合する場合（ユーザー確認必須）

#### 振り返りで作成したIssueの扱い

振り返り（/reflecting-sessions）で問題を発見しIssue化した場合も、**そのセッション内で実装まで完遂**する。

| ❌ 禁止パターン | ✅ 正しいパターン |
| -------------- | ---------------- |
| 「フォローアップIssueを作成しました。次は？」 | Issue作成 → 即座に実装開始 |
| 「今後の改善としてIssue化しました」 | Issue作成 → 同セッションで実装 |

**禁止用語**: 振り返りで作成したIssueやその説明に「フォローアップ」という表現を使うことは禁止。この表現は「後で対応する」という誤認識を誘発する。

**理由**: 振り返りで発見した問題もセッション内Issueであり、「セッション内で作成したIssueは実装まで完遂」ルールが適用される。

#### 例外: PRで導入したバグは別Issueにしない

レビューで「このPRで書いたコードにバグがある」と指摘された場合、別Issueを作成せず**同じPRで修正**する。

| バグの発生源 | 対応 |
| ------------ | ---- |
| このPRで書いたコード | 同じPRで修正（Issue作成しない） |
| 既存コード（偶然発見） | 別Issue作成 |

詳細は `reviewing-code` Skill の「範囲内/範囲外の判断基準」を参照。

#### 移行PRのバグ対応

移行PR（Python→TypeScript、設定ファイルの参照先変更等）では、**移行先コードのバグは同じPRで修正**する。

| バグの位置 | 対応 |
| ---------- | ---- |
| 移行先コード（有効化されるコード） | 同じPRで修正（「既存コードの問題」として別Issue化しない） |
| 移行元コード（削除するファイル） | 修正不要（削除されるため） |
| 関連しない既存コード | 別Issue作成 |

**理由**: 移行PRがマージされた瞬間から移行先コードが有効になる。移行先にバグがあれば、そのバグはマージ直後から本番に影響する。

**例**: Python→TypeScript移行で:

- ❌ 「移行先のバグは既存コードの問題なので別Issue」→ バグ込みでマージされる
- ✅ 「移行先のバグはこのPRで修正」→ バグなしでマージされる

**背景**: PR #3542 でPython→TypeScript移行時、AIレビューで移行先（TypeScript）のバグを指摘されたが「既存コードの問題」として別Issue化しようとした。ユーザーの指摘により同PRで修正。

### 機能実装後の設計レビュー

新機能・フック・スクリプトを実装したら、以下の観点で懸念点を洗い出し、該当するものはIssue化する:

| 観点 | チェック項目 |
| ---- | ------------ |
| **並行性** | 複数セッション/プロセスが同時実行したら？ファイルロックは必要？ |
| **エッジケース** | 空入力、巨大データ、不正形式、タイムアウト時の動作は？ |
| **依存関係** | 外部コマンド（gh, git）が失敗したら？ネットワーク断は？ |
| **状態管理** | ファイル/DBの整合性は？クリーンアップは自動？ |
| **セキュリティ** | 入力のサニタイズは？秘密情報の露出リスクは？ |
| **拡張性** | 将来の変更に対応しやすい設計か？ハードコードはないか？ |

**タイミング**: PR作成前、またはマージ直後に実施

**出力**: 懸念点があればIssueを作成（「将来の改善」としてラベル付け）

### Issueのクローズ方法

GitHubの組み込み機能を使い分ける（ラベルではなく）:

| Close理由 | 用途 |
| --------- | ---- |
| **Completed** | 解決済み、対応完了 |
| **Not planned** | 対応しない、キャンセル、着手前に中止 |
| **Duplicate** | 他のIssueと重複（重複先を指定） |

**操作**: 「Close issue」ボタン横の▼から選択

### Sub-Issueの活用

3つ以上の独立したPRが必要になりそうな場合、sub-issueで親子関係を作成する。

操作方法の詳細は `managing-development` Skillを参照。

### ブロック後の対応

フックによるブロック後も、**テキストのみの応答で終わらず、必ずツール呼び出しを続ける**。

| 状況 | ❌ 悪い例 | ✅ 良い例 |
| ---- | --------- | --------- |
| worktree削除がブロックされた | 「cwdが中にあるためブロックされました」と説明して終了 | 説明後、`cd /main/repo` を実行してから再試行 |
| マージがブロックされた | 「レビュー未完了です」と説明して終了 | 説明後、`gh pr view` でレビュー状況を確認 |
| 編集がブロックされた | 「mainでは編集できません」と説明して終了 | 説明後、worktreeを作成して移動 |

**理由**: Claude Codeのエージェントループは `while(tool_call)` 構造。テキストのみの応答はループを停止させ、ユーザー入力待ちになる。

**原則**: ブロックは「やり方を変えろ」という指示。停止ではなく、代替アクションを実行する。

#### 重要: ブロック時の根本原因解消

ブロックされた場合、**メッセージを必ず読み、根本原因を解消してから再試行**する。

| ❌ 悪いパターン | ✅ 正しいパターン |
| -------------- | ---------------- |
| ブロックメッセージを読まずに同じ操作を再試行 | メッセージを読んで指示に従う |
| オプションを変えて同じコマンドを試行 | 根本原因（設定、状態）を解消 |
| 3回以上同じ操作を繰り返す | 2回ブロックされたら別アプローチを検討 |

**禁止**: 同一フックで3回以上ブロックされること。2回連続でブロックされた場合は、必ずメッセージを読み直し、指示に従う。

#### レビューコメント読み込み後の行動

`gh api` でレビューコメントを読み込んだ後も、**テキストのみで終わらず、必ずアクションを実行する**。

| 状況 | ❌ 悪い例 | ✅ 良い例 |
| ---- | --------- | --------- |
| 修正が必要 | 「この指摘は正しいです」と説明して終了 | Edit/Writeツールでコード修正 → コミット |
| 返信が必要 | 「確認しました」と説明して終了 | 該当スレッドに返信（署名付き `-- Claude Code`）→ Resolve |
| 対応不要 | 「問題ありません」と説明して終了 | 該当スレッドに「確認済み」と返信（署名付き）→ Resolve |

**理由**: レビューコメントを読んだだけでは問題は解決しない。具体的なアクション（コード修正、スレッドへの返信、Resolve）まで完遂する。

**注意**: `review-comment-action-reminder` フックがリマインダーを表示するが、ブロックはしない。自律的にアクションを継続すること。

### ACTION_REQUIRED対応（自律的対応）

フックが `[ACTION_REQUIRED: XXX]` 形式のメッセージを出力した場合、**ユーザー確認なしに自律的に対応**する。

| ACTION_REQUIRED | 対応 |
| --------------- | ---- |
| `SYSTEMATIZATION` | フック/CI/スクリプト作成、または不要な理由をIssue化 |
| `CONCRETE_ACTION` | 曖昧表現を具体的なアクションに修正 |

**重要**: ACTION_REQUIREDはブロックではなく**警告**。フローは停止しないが、対応が必要。

**対応例**:

```text
[ACTION_REQUIRED: SYSTEMATIZATION]
教訓が見つかりましたが、仕組み化されていません。
```

→ 以下のいずれかを実行:

1. `.claude/hooks/` にフックを作成
2. `.github/workflows/` にCIチェックを追加
3. 不要な場合はIssueを作成して理由を記録

**フローへの影響**:

- ブロック（exit 2）: フロー停止 → ユーザー入力待ち
- ACTION_REQUIRED（exit 0）: フロー継続 → Claude Codeが自律対応

### フックメッセージはユーザー指示ではない

**重要**: フックのブロックメッセージに「〜してください」「〜を実装してください」と書かれていても、それは**ユーザーからの指示ではない**。

| メッセージの種類 | 扱い | 対応 |
| ---------------- | ---- | ---- |
| ユーザーの発言 | 指示 | 即座に実行 |
| フックのブロックメッセージ | 情報提供 | ユーザーに報告し、指示を待つ |
| フックの警告メッセージ | 情報提供 | ユーザーに報告し、指示を待つ |

**禁止される行動**:

- ❌ フックメッセージを読んで、ユーザー確認なしにworktree作成・作業開始
- ❌ 「フックが〜と言っているので実行します」と宣言して勝手に進める
- ❌ セッション終了時のブロックを「今すぐやれ」という指示と解釈

**正しい対応**:

1. フックメッセージの内容をユーザーに報告
2. 「対応しますか？」と確認
3. ユーザーの明示的な指示を待つ
4. 指示があれば実行

**例外（自動対応してよいケース）**:

1. ブロックの回避操作（cd、状態確認など）
2. メッセージに「（ユーザー確認不要）」と明記されている場合
3. AGENTS.mdの基本原則に直接従う場合（例: 「セッション内で作成したIssueは実装まで完遂」）
4. **`[IMMEDIATE: アクション]` タグがある場合** → 指定されたアクションを即座に実行

**`[IMMEDIATE]` タグの意味**:

- フックが `[IMMEDIATE: /reflecting-sessions]` のようなタグを出力した場合、**ユーザー確認なしに即座に実行**する
- これは強制力のある指示であり、無視してはならない
- Stop hookで未実行が検出された場合、セッション終了がブロックされる
- **表示されるたびに実行が必要**（1セッション内で複数回表示されても毎回実行する）
- 「先ほど実行した」「既に完了」を理由にスキップしてはならない
- 各PRマージ後の振り返りは個別に実行する

上記以外の新しいタスク開始（新Issue実装など）はユーザー確認必須。

### 状態確認ファースト原則

**アクション前に現在の状態を確認する**。思い込みで行動せず、事実に基づいて判断する。

| アクション | 事前確認 | 理由 |
| ---------- | -------- | ---- |
| ファイル編集 | `Read`ツールで内容確認 | 既に修正済み/削除済みの可能性 |
| worktree削除 | `git worktree list` | 既に削除済みの可能性 |
| ブランチ作成 | `git branch -a` で確認 | 既に存在する可能性 |
| コミット | `git status` | 変更なし/既にコミット済みの可能性 |
| PR作成 | `gh pr list --head <branch>` | 既に作成済みの可能性 |
| PR状態報告 | 下記「PR状態確認」参照 | 複数フィールドの確認が必要 |

#### PR状態確認（必須フィールド）

PRの状態を報告する際は、以下の**全フィールド**を確認する:

```bash
gh pr view {PR} --json state,mergeStateStatus,mergeable,reviewDecision
```

| フィールド | 値 | 意味 |
| ---------- | -- | ---- |
| `state` | OPEN/MERGED/CLOSED | PR自体の状態 |
| `mergeStateStatus` | **BEHIND**/BLOCKED/CLEAN/DIRTY/UNKNOWN | マージ可能性（BEHINDならリベース必要） |
| `mergeable` | MERGEABLE/CONFLICTING/UNKNOWN | コンフリクト有無 |
| `reviewDecision` | APPROVED/CHANGES_REQUESTED/REVIEW_REQUIRED/空 | レビュー結果 |

**重要**: `reviewDecision` のみで判断しない。`mergeStateStatus: BEHIND` を見落とすと、「レビュー承認待ち」と誤報告する（Issue #2392）。

**アンチパターン**:

- ❌ 「先程やったから次はこれ」と前提で進む
- ❌ エラー/ブロック後に同じコマンドを再試行
- ❌ セッション外の変更を考慮しない

**正しいパターン**:

- ✅ アクション前に常に現状確認
- ✅ ブロック後は状態を再確認してから次のアクション
- ✅ 「既に完了している可能性」を常に念頭に置く

**例**: worktree削除がブロックされた場合

```bash
# ❌ 悪い例: 即座に再試行
git worktree remove .worktrees/issue-123  # ブロック
git worktree remove .worktrees/issue-123  # また同じことを試す

# ✅ 良い例: 状態確認してから判断
git worktree remove .worktrees/issue-123  # ブロック
git worktree list                          # 現状確認
# → 削除済みなら何もしない
# → 存在するなら原因を調べて対処
```

### エラー時の行動指針

**同じエラーを繰り返さない**。エラー発生時は根本原因を分析し、別のアプローチを試す。

| 状況 | 対応 |
| ---- | ---- |
| 同じエラーが2回連続 | エラーメッセージを分析し、別アプローチを試す |
| コマンドが見つからない | `which`で確認、代替ツールを検討 |
| 権限・設定エラー | 設定ファイルを確認、環境を調査 |
| オプション違いで同じエラー | オプションではなく根本原因を解決 |

**禁止**: 同じコマンドを3回以上試行すること

**例**: `uv run ruff`でエラーが発生した場合

```bash
# ❌ 悪い例: オプションを変えて同じパターンを繰り返し
uv run ruff format file.py                    # エラー: No [project] table
uv run --project .claude ruff format file.py  # エラー: No [project] table
uv run --directory .claude ruff format file.py # エラー: No [project] table

# ✅ 良い例: エラーメッセージを分析し、別アプローチを試す
uv run ruff format file.py           # エラー: No [project] table
# → エラーを分析: pyproject.tomlに[project]がない
# → 別アプローチ: uvxを使用（[project]不要）
uvx ruff format file.py              # 成功
```

**エラー分析のポイント**:

1. エラーメッセージを**正確に読む**（「No [project] table」→ [project]が問題）
2. 何が要求されているか理解する（uv run は [project] を必要とする）
3. その要求を満たすか、要求しない別ツールを使う

### 選択肢提示時のルール

複数の選択肢がある場合は、テキストで列挙せず**AskUserQuestionツール**を使用する。

| ❌ 悪い例 | ✅ 良い例 |
| -------- | -------- |
| 「A案、B案、C案があります。どれにしますか？」 | AskUserQuestion で選択肢を提示 |

**例**:

```json
{
  "questions": [{
    "question": "どの方式で実装しますか？",
    "header": "実装方式",
    "options": [
      {"label": "A案: シンプル", "description": "最小限の実装"},
      {"label": "B案: 拡張性重視", "description": "将来の変更に対応"}
    ],
    "multiSelect": false
  }]
}
```

**例外**:

- 選択肢が1つで推奨案のみ → テキストで提示可

**重要**: ブロック後にユーザーへ確認を取る場合も、テキストで質問せず**AskUserQuestion**を使用する。テキストのみの応答はエージェントループを停止させる。

| ❌ 悪い例 | ✅ 良い例 |
| -------- | -------- |
| 「進みますか？」とテキストで質問 | AskUserQuestion で選択肢を提示 |

## プロジェクト概要

dekita! - ハンズオン・ワークショップ向けのリアルタイム進捗共有ツール

**本番URL**: <https://dekita.app/>

**構成**:

- `frontend/` - React + TanStack Router (Vite)
- `worker/` - Cloudflare Workers + Hono
- `shared/` - 共通の型定義

## 環境情報

| 環境 | Frontend | API |
| ---- | -------- | --- |
| 本番 | <https://dekita.app> | <https://api.dekita.app> |
| プレビュー | PR毎に生成 | PR毎に生成 |
| ローカル | 起動時のログを確認 | 起動時のログを確認 |

## コマンド

| 用途 | コマンド |
| ---- | -------- |
| ビルド | `pnpm build` |
| テスト | `pnpm test:ci` |
| Lint | `pnpm lint` |
| 型チェック | `pnpm typecheck` |

### CI監視

PRのCI監視には`ci_monitor`（TypeScript版）を使用する。

| ❌ 禁止 | ✅ 推奨 |
| ------- | ------- |
| `gh pr checks --watch` | `bun run .claude/scripts/ci_monitor_ts/main.ts <PR番号> --session-id <SESSION_ID>` |

※ `<SESSION_ID>`はUserPromptSubmit hookで提供されるセッションID（UUID形式）

**例**: `bun run .claude/scripts/ci_monitor_ts/main.ts 1234 --session-id 3f03a042-a9ef-44a2-839a-d17badc44b0a`

**重要**: `--session-id`を省略するとppidフォールバックが発動し、ログが正しいセッションと紐付かなくなる

**ci_monitorの利点**:

- BEHIND検知 → 自動リベース
- レビュー完了検知 → コメント取得
- CI失敗 → 即座に通知

### Code Simplifier

AI生成コードの肥大化・複雑化を防止する。

**呼び出し方法**:

```bash
/simplifying-code
```

**Skillの特徴**:

- スコープ制限: このPR/ブランチでmainから変更した部分のみ対象
- 機能保持: テスト結果が変わる変更は禁止
- パターン維持: プロジェクトの既存スタイルを尊重
- 大きな変更は提案のみ（自動適用禁止）

> [!WARNING]
> **code-simplifierは動作保証をしない。出力をコミットする前に:**
>
> - 変更された関数のエッジケースを手動検証（空文字、特殊文字、境界値等）
> - 特に条件分岐が減った場合は、削除された分岐のケースを確認

### フック開発

**全てのフックはTypeScript（Bun）で実装する**。

| 種類 | 対応 |
| ---- | ---- |
| フック | `.claude/hooks/handlers/` 配下にTypeScriptファイル（例: `<hook_name>.ts`）として作成 |

**理由**:

- TypeScriptの型安全性
- Bunの高速起動（フックは毎回起動されるため重要）
- 統一されたコードベース

**注**: Python→TypeScript移行は完了済み（Issue #3496, #3649）

## コスト方針

- **実装コスト**: 度外視OK
- **運用コスト**: 最小化（Cloudflare Free tier活用）

## セキュリティポリシー

- 非公式GitHub Actionsの導入禁止（例外: `astral-sh/*`（uv公式）、`oven-sh/*`（Bun公式）は許可）
- 外部ツール提案前にセキュリティリスクを評価
- Dependabot PRではE2Eテスト自動実行しない（Pwn Request攻撃対策）

## ドキュメント更新

以下の変更時は対応ドキュメントの更新を確認:

| 変更内容 | 更新対象 |
| -------- | -------- |
| ユーザーデータ収集、外部サービス追加 | プライバシーポリシー |
| 主要機能の追加・削除 | 利用規約、FAQ |
| 環境構築関連 | README.md |
| 開発フロー、コーディング規約 | AGENTS.md / Skills |

**更新基準**:

- **AGENTS.md**: プロジェクト全体の方針、基本原則、例外事項
- **Skills**: 実際の手順、ワークフロー、詳細な作業フロー

**重要**: `privacy`/`terms`セクションは**ja.jsonのみ**に記載（CIで自動チェック）

---

## Skills

Claudeがコンテキストに基づいて自動で発見・使用する詳細手順。

| Skill | 用途 |
| ----- | ---- |
| `reflecting-sessions` | セッション振り返り、五省、なぜなぜ分析 |
| `analyzing-trends` | 直近3日間の傾向分析（fix比率、ブロックパターン） |
| `managing-development` | Worktree、PR作成、CI監視、マージ |
| `reviewing-code` | AIレビュー確認、コメント対応、Resolve |
| `applying-standards` | コーディング規約、テスト、Lint |
| `implementing-hooks` | フック詳細仕様、設計原則 |
| `troubleshooting` | エラー、問題発生時の解決策 |
| `adding-perspectives` | 振り返り観点の追加 |
| `exploring-claude-code` | Claude Code機能調査・提案 |
| `authoring-skills` | Skill作成・改善、品質チェック |
| `simplifying-code` | AI生成コードの簡素化、PR作成前チェック |

**トリガー例**:

- `/reflecting-sessions` → セッション終了時の振り返り
- `/analyzing-trends` → 複数セッションの傾向分析
- 「PRを作成したい」→ `managing-development`
- 「レビューコメントを確認」→ `reviewing-code`
- フック修正・実装 → `implementing-hooks`
- 「エラーが出る」「動かない」→ `troubleshooting`
- 「新しいSkillを作成したい」→ `authoring-skills`

> **補足**: 複数のSkillが該当する場合、Claudeがコンテキストから最適なSkillを選択。必要に応じて複数Skillを組み合わせて対応。

### Skill使用の判断基準

**重要**: 「単純かどうか」ではなく「該当する作業かどうか」でSkill使用を判断する。

| ❌ 誤った判断 | ✅ 正しい判断 |
| ------------ | ------------ |
| 「単純な実装だからSkill不要」 | 「フック修正だからimplementing-hooks参照」 |
| 「小さな変更だからSkill不要」 | 「PR作成だからmanaging-development参照」 |

**理由**: 既存の実装パターンを見落とし、レビューで指摘されるリスクを回避するため。

---

## Review guidelines

AIコードレビュー（Gemini, Codex, Copilot等）向けの品質基準。

### 優先度定義

| 優先度 | 対象 | 例 |
| ------ | ---- | -- |
| **P0** | 即座に修正必須 | セキュリティ脆弱性、データ破損、本番障害 |
| **P1** | マージ前に修正 | バグ、設計問題、パフォーマンス劣化、テスト不足 |
| **P2** | 改善推奨 | コードスタイル、ドキュメント、リファクタリング |

### 設計品質チェック（P1）

以下の設計原則違反は **P1** として報告する:

#### 結合度（Coupling）

**低結合を維持する**。モジュール間の依存を最小限に。

| 問題パターン | 説明 |
| ------------ | ---- |
| 神クラス/神関数 | 1つのモジュールが多くの責務を持ち、多数の外部依存がある |
| 循環依存 | A→B→C→A のような循環参照 |
| 具象依存 | インターフェースではなく具体的な実装に依存 |
| グローバル状態 | 複数モジュールが共有するグローバル変数 |
| 密結合 | 内部実装の詳細に依存（private メソッドの直接呼び出し等） |

#### 凝集度（Cohesion）

**高凝集を維持する**。関連する機能を1つのモジュールにまとめる。

| 問題パターン | 説明 |
| ------------ | ---- |
| 偶発的凝集 | 関連のない機能が同じモジュールに存在 |
| 論理的凝集 | 似た処理だが異なる目的の機能が混在 |
| 散在する機能 | 1つの機能が複数モジュールに分散 |
| ユーティリティ肥大化 | `utils.ts` に無関係な関数が集積 |

#### 単一責任原則（SRP）

- 1つのモジュール/クラス/関数は1つの責務のみを持つ
- 「この変更理由は1つか？」で判断
- 複数の理由で変更される場合は分割を検討

#### 変更影響範囲

- PRの変更が関連しないファイルに波及していないか
- 1つの変更が多数のファイルを修正する場合は設計を見直す

### セキュリティチェック（P0/P1）

以下は必ず報告する:

- 認証・認可の欠如または不備
- 入力値の検証不足（SQLインジェクション、XSS等）
- 秘密情報のハードコード
- 安全でない暗号化・ハッシュ
- パス検証の不備（下記参照）

#### パス検証パターン

ファイルパスが信頼されたディレクトリ内にあるかを検証する際、`startsWith()` は危険:

| パターン | 安全性 | 説明 |
| -------- | ------ | ---- |
| `resolved.startsWith(trustedDir)` | ❌ 危険 | `../hooks-evil/` でトラバーサル可能 |
| `!rel.startsWith('..') && !rel.startsWith('/')` | ✅ 安全 | trustedDir外やルートパスを正しく検出 |

**注**:

- `rel = relative(trustedDir, resolved)` で相対パスを取得
- `resolved` と `trustedDir` は事前に `resolve()` で絶対パス化が必要
- `..` だけでなく `/` で始まるパスも弾くことで、シンボリックリンク経由のバイパスを防ぐ
- `relative` は Node.js の `path.relative`、Python の `os.path.relpath` に相当

**背景**: PR #2842 で `startsWith()` を使用し、AIレビューでP1指摘を受けた。

### テストカバレッジ（P1）

- 新規コードにテストがあるか
- エッジケース（空入力、境界値、エラー）がテストされているか
- モックが適切に使用されているか

### このプロジェクト固有のルール（P1）

- `console.log` は開発環境のみ（`import.meta.env.DEV` でガード）
- Sentryの `setTag`/`setContext` はグローバルスコープ禁止（`withScope` 使用）
- 型の `any` 使用は原則禁止（やむを得ない場合はコメント必須）
- i18n翻訳は `ja.json` のみに記載

### 修正漏れチェック（P1）

共通パターン（関数、定数、設定値）を変更するPRでは、以下を確認:

- [ ] 同様のパターンが他のファイルに存在しないか？（`rg "パターン"` で確認）
- [ ] 全ての呼び出し箇所が修正されているか？
- [ ] 修正漏れがある場合はP1として報告

**背景**: #2054 で `json.dumps` の修正時に2箇所の漏れがあり、#2065 で再修正が必要になった。

### パターンマッチング実装（P1）

正規表現によるパターンマッチングを実装する際は以下を確認:

| チェック項目 | 説明 |
| ------------ | ---- |
| **複数条件の組み合わせ** | 「成功条件の存在」を積極的に確認し、「失敗条件の不在」のみで成功と判断しない |
| **フラグの一貫性** | `re.IGNORECASE` 等のフラグは全ての検索で統一する |
| **テストのリアリティ** | 実際の出力を模倣（stdout/stderr両方を考慮） |

**背景**: #2099 でブランチ削除失敗パターンのみでマージ成功と判定し、誤検知が発生。#2101 で修正。

### AIレビュー間の矛盾時の対応（P1）

複数のAIレビュー（Copilot、Gemini、Codex等）の結果が矛盾する場合の対応方針。

| 状況 | 対応 |
| ---- | ---- |
| Copilot「問題なし」+ Gemini「問題あり」 | **Geminiの指摘を優先**。Issue作成必須 |
| 複数AIが異なる指摘 | 全ての指摘を検討し、妥当なものは対応 |
| セキュリティ関連の指摘 | **必ずIssue化**。「問題なし」で無視しない |

**原則**:

1. **「問題なし」は採用しない**: あるAIが「問題なし」としても、別のAIの指摘を無視しない
2. **セキュリティ指摘は最優先**: medium以上のセキュリティ指摘は必ずIssue化
3. **統合判断**: 複数AIの結果を統合し、最も保守的な判断を採用

**背景**: PR #2702 でCopilotは「問題なし」としたが、Geminiは2つのReDoS脆弱性を指摘。Issueが作成されずにマージされ、セキュリティ問題が本番に入った（Issue #2709）。

---

## 関連ドキュメント

- `frontend/src/routes/privacy.tsx` - プライバシーページ
- `frontend/src/routes/terms.tsx` - 利用規約ページ
- `frontend/src/routes/faq.tsx` - FAQページ
