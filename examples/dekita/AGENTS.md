# AGENTS.md

AIコーディングエージェント向けのプロジェクト指示。

詳細な手順はSkillsに分離されています。Claudeが自動で発見・使用します。

---

## 基本原則

ユーザーからの依頼・要望は全て**指示**として扱い、即座に実行する。

- 「承知しました」だけで終わらない
- 実行してから報告する
- **差し込みタスク優先**: CI待ちなどのブロッキング中に簡単なタスク（Issue作成、コメント追加など）が依頼されたら先に処理
- **マージまで完遂**: タスク完了時はPR作成で止まらず、CI監視→レビュー対応→マージまで実行
  - ❌ 「マージしますか？」「マージしてよいですか？」と確認を求める
  - ❌ CIパス・レビュー完了後にユーザーの次の指示を待つ
  - ✅ マージ可能になったら即座に `gh pr merge` を実行
- **エラー発見時の自動Issue作成**: 問題を発見したら、まずIssueを作成してから作業を続行する（ユーザーへの確認不要）
- **オープンIssueの問題は未解決**: Issueを作成しても、クローズされるまでその問題は存在し続ける。作業中は常にオープンIssueの問題を意識し、手動で回避すること
- **機能実装後の懸念点洗い出し**: 新機能やフックを実装したら、設計上の懸念点を自発的に洗い出してIssue化する（ユーザーに指摘される前に）
- **タスク完了時の次ステップ提案**: タスク完了後、次にやろうとしていることを提案する。ユーザーが承認するだけで次に進めるようにする。次にやることがなければ「何をしますか？」と聞く
- **セッション開始時ファイルは最優先タスク**: `claude /path/to/file.md` のようにファイルを指定して起動された場合、そのファイルの内容は**最優先タスク**として扱う。他の作業（handoff改善、リファクタリング等）より先に、指定されたファイルの内容を実行すること
- **選択肢提示時はAskUserQuestion使用**: 複数の選択肢がある場合、テキストで列挙せずAskUserQuestionツールを使用する。ユーザーの入力負担を減らし、選択ミスを防ぐ
- **セッション内で作成したIssueは実装まで完遂**: Issue作成だけで「完了」としない。作成したIssueは**確認を求めずに即座に着手**し、同じセッション内で実装・マージまで完遂する（大規模タスクや競合時はユーザー確認）
- **仕組み化 = ドキュメント + 強制機構**: 「仕組み化」を謳う場合、ドキュメント追加だけでは不十分。違反を**ブロック**するフック/CI/ツール等の強制機構まで実装して初めて完了
- **Dogfooding原則**: 新機能（特にデータ処理スクリプト）実装時は、その機能が解決する問題を**自分で再現・体験**してから実装完了とする。実データでテストし、エッジケース（空、改行含む、大量データ）を確認すること
- **AIレビューは最後の砦**: AIレビュー（Copilot、Codex、Gemini等）を「安全網」として期待しない。AIレビューで検出されることを理由にIssue作成やテスト追加を省略してはならない
  - ❌ 「レビューで検出可能だからIssue不要」
  - ❌ 「AIレビューが指摘してくれたから問題なし」
  - ✅ AIレビューは**存在しないもの**として行動し、自分で検証・対策する
  - ✅ AIレビューで問題が検出された場合、「なぜ自分で事前に気づけなかったか」を振り返る
- **ユーザーフィードバック = 修正 + 仕組み化**: ユーザーが問題を指摘した場合、その問題の修正だけでは不十分。類似問題を将来検出できる仕組み化が必須
  - ❌ 問題を修正して「完了」とする
  - ❌ 「今後気をつける」と記述して終了
  - ✅ `/add-perspective` で振り返り観点を追加
  - ✅ フック/CI/ツールで自動検出を実装
  - ✅ 仕組み化が不要な理由をIssueに記録

### オープンIssueと行動の関係

| Issueの状態 | 意味 | 私の行動 |
| ----------- | ---- | -------- |
| **オープン** | 問題は未解決、対策は未実装 | 常に意識し、手動で回避する |
| **クローズ** | 対策が実装済み | 仕組みが守ってくれるので意識不要 |

**例**: 「別セッション競合防止」のIssueがオープンなら、全ての作業で「別セッションが作業中かも」と懸念しながら取り組む。フックで強制ブロックされなくても、自分で確認・回避する。

### Issue作業開始前の確認（必須）

**全てのIssueに対して**、作業開始前に以下を確認:

```bash
# 1. 既存worktreeの確認
git worktree list | grep -iE "issue-<番号>|<キーワード>"

# 2. 既存PRの確認
gh pr list --search "<Issue番号> OR <キーワード>"
```

**以下のいずれかに該当する場合、ユーザーに確認してから作業開始**:

| 状態 | 意味 | 対応 |
| ---- | ---- | ---- |
| worktreeが存在 & ロック中 | 別セッションが作業中 | 作業しない |
| worktreeが存在 & 未コミット変更あり | 作業途中の可能性 | 確認してから判断 |
| worktreeが存在 & 直近1時間以内のコミット | 最近まで作業していた | 確認してから判断 |
| PRが存在 & レビュー進行中 | 別セッションが対応中 | 作業しない |

**重要**: 「ロックされていないから大丈夫」と自己判断しない。状況をユーザーに報告し、指示を仰ぐ。

### オープンPRへの介入禁止

**オープンPRが存在するIssueには一切触れない**。これは最重要ルールである。

| 状況 | 禁止される行動 | 理由 |
| ---- | -------------- | ---- |
| PR #XがオープンでCI待ち | レビューコメント対応を開始 | 別セッションが担当中 |
| PR #Xがオープンでレビュー中 | コード修正をプッシュ | コンフリクトの原因 |
| PR #Xがオープン | 同じIssueの新PRを作成 | 重複作業 |

**PRとworktreeの関係**:

- PRのブランチ名（例: `feat/issue-123-xxx`）とworktree名（例: `issue-123`）は対応する
- worktreeが存在しなくてもPRがオープンなら介入禁止
- PRがクローズ/マージ済みなら、同じIssueの新作業は可能

**確認コマンド**:

```bash
# オープンPRとそのブランチを一覧
gh pr list --state open --json number,headRefName,title --jq '.[] | "#\(.number) \(.headRefName): \(.title)"'
```

### fork-sessionの行動指針

**fork-sessionの判定方法**: SessionStartのSession IDと、UserPromptSubmitのSession IDが異なる場合、自分はfork-sessionである。

**fork-sessionとして禁止される行動**:

| ❌ 禁止 | 理由 |
| ------ | ---- |
| 「他のIssueはfork-sessionに任せます」という発言 | 自分がfork-sessionであることを認識していない |
| 親セッションが作業中のIssueへの着手 | 競合・コンフリクトの原因 |
| 自分が親セッションであるかのような振る舞い | 役割の誤認 |
| 「私が担当し、他のセッションに割り振ります」 | fork-sessionにはその権限がない |

**fork-sessionとして推奨される行動**:

| ✅ 推奨 | 説明 |
| ------ | ---- |
| `fork-session-collaboration-advisor`の提案に従う | 独立したIssue候補から選択 |
| 親セッションの作業中Issueを避ける | 表示された親セッションのIssueには着手しない |
| 独立した作業を選択 | 競合しないファイルを変更するIssue |

**背景**: PR #2514の振り返りセッションで、fork-sessionが「他のIssueはfork-sessionに任せます」と発言し、自分が親セッションであるかのように振る舞った（Issue #2519）。

### Issue作成が必要なケース

以下の問題を発見した場合、**報告だけで終わらず必ずIssueを作成**する:

| カテゴリ | 具体例 |
| -------- | ------ |
| フックの問題 | 予期せぬブロック、誤検知、エラーメッセージの矛盾 |
| ツールのバグ | スクリプトの動作不良、期待と異なる出力 |
| 設計上の課題 | 競合状態、エッジケース未対応、仕様の曖昧さ |
| ドキュメント | 手順の不備、古い情報、説明不足 |
| CI/CD | テストの不安定、ビルド失敗の再現、デプロイ問題 |

**手順**:

1. 問題を発見したら、作業を一時中断
2. `gh issue create` でIssueを作成（タイトル・本文に再現手順を含める）
3. 作成したIssue番号をユーザーに報告
4. 元の作業を続行

**注意**: 「問題があります」「動作していません」とユーザーに報告するだけでは不十分。Issue作成まで完了させる

#### Issue作成前チェックリスト

Issue作成時に以下を事前に準備する。これらが不足すると `issue-body-requirements-check` や `issue-priority-label-check` でブロックされる:

| 項目 | 内容 | 検証フック |
| ---- | ---- | ---------- |
| **優先度ラベル** | P0〜P3のいずれかを決定 | `issue-priority-label-check` |
| **なぜ/背景** | 問題発生の経緯、影響範囲 | `issue-body-requirements-check` |
| **現状/実際の動作** | 現在どう動いているか、再現手順 | `issue-body-requirements-check` |
| **期待動作** | あるべき状態 | `issue-body-requirements-check` |
| **対応案** | 具体的な解決策 | `issue-body-requirements-check` |

**優先度の判断基準**:

| ラベル | 基準 | 例 |
| ------ | ---- | -- |
| P0 | 本番障害、セキュリティ | 認証バイパス、データ消失 |
| P1 | 重要機能のバグ、ブロッカー | CI失敗、主要フロー停止 |
| P2 | 改善、軽微なバグ | UX改善、エッジケース対応 |
| P3 | ドキュメント、リファクタリング | typo修正、コード整理 |

**テンプレート例**:

```markdown
## なぜ
[問題が発生した背景・経緯を記述]

## 現状
[現在どう動いているか、再現手順を記述]

## 期待動作
[あるべき状態を記述]

## 対応案
[具体的な解決策を記述]
```

#### 「後でフォローアップ」発言時のIssue作成（必須）

レビューコメントや会話で以下のような発言をする場合、**必ず同時にIssueを作成**する:

| 禁止される発言パターン | 正しい対応 |
| ---------------------- | ---------- |
| 「今後のフォローアップとして検討します」 | Issue作成してから発言 |
| 「将来的に対応します」 | Issue作成してから発言 |
| 「別途対応が必要です」 | Issue作成してから発言 |
| 「スコープ外なので後で」 | Issue作成してから発言 |

**理由**: Issueを作成しないフォローアップ発言は「何もしない」と同義。忘れられ、対応されない。

**正しい例**:

```text
今回のスコープ外のため、Issue #1488 を作成しました。
```

**禁止される例**:

```text
今後のフォローアップとして検討します。（Issue作成なし）
```

**チェックリスト**: 「後で」「将来」「フォローアップ」「別途」などの単語を使う前に:

1. 本当にスコープ外か確認
2. スコープ外なら`gh issue create`でIssue作成
3. Issue番号を含めてコメント

#### 「心がけ」系表現の禁止

以下の表現は**再発防止策ではない**ため、使用禁止:

| 禁止される表現 | 理由 |
| -------------- | ---- |
| 「今後意識する」 | 仕組み化されていない |
| 「気をつける」 | 記憶に依存する |
| 「心がける」 | 強制力がない |
| 「注意する」 | 具体的アクションがない |
| 「留意する」 | 検証不可能 |

**正しい対応**:

| 状況 | 対応 |
| ---- | ---- |
| 既存ルールでカバー済み | 「既存ルールでカバー済み。追加アクション不要」で終了 |
| 新しい問題を発見 | Issue作成 → 仕組み化（フック/CI等の強制機構 + ドキュメント化） |

**理由**: 「心がけ」は人間の記憶に依存し、再現性がない。問題の再発防止には**仕組み**が必要。

#### セッション内で作成したIssueの扱い

セッション中に作成したIssueは、**ユーザー確認なしで即座に実装を開始**し、**そのセッション内で実装まで完遂**する。

| ❌ 禁止パターン | ✅ 正しいパターン |
| -------------- | ---------------- |
| Issue作成 → 「完了」としてtodo更新 | Issue作成 → 実装 → PR → マージ → 「完了」 |
| 「Issue #xxx を作成しました。次は？」 | 「Issue #xxx を作成しました。実装を開始します」 |
| 「続行しますか？」「実装しますか？」 | 確認なしで即座に実装開始 |
| 「コンテキストが○○%です。続行しますか？」 | コンテキスト使用率に関係なく着手 |

**重要**: Issue作成後に確認を求めることは禁止。以下の理由で「続行しますか？」と聞いてはならない:

- コンテキスト使用率
- 時間がかかりそう
- 「念のため確認」

**例外**:

- 別セッションで作業中のIssueと競合する場合（ユーザー確認必須）
- 実装に30分以上かかる大規模タスクの場合（ユーザー確認必須）

#### 振り返りで作成したIssueの扱い

振り返り（/reflect）で問題を発見しIssue化した場合も、**そのセッション内で実装まで完遂**する。

| ❌ 禁止パターン | ✅ 正しいパターン |
| -------------- | ---------------- |
| 「フォローアップIssueを作成しました。次は？」 | Issue作成 → 即座に実装開始 |
| 「今後の改善としてIssue化しました」 | Issue作成 → 同セッションで実装 |

**禁止用語**: 振り返りで作成したIssueやその説明に「フォローアップ」という表現を使うことは禁止。この表現は「後で対応する」という誤認識を誘発する。

**理由**: 振り返りで発見した問題もセッション内Issueであり、「セッション内で作成したIssueは実装まで完遂」ルールが適用される。

#### 例外: PRで導入したバグは別Issueにしない

レビューで「このPRで書いたコードにバグがある」と指摘された場合、別Issueを作成せず**同じPRで修正**する。

| バグの発生源 | 対応 |
| ------------ | ---- |
| このPRで書いたコード | 同じPRで修正（Issue作成しない） |
| 既存コード（偶然発見） | 別Issue作成 |

詳細は `code-review` Skill の「範囲内/範囲外の判断基準」を参照。

### 機能実装後の設計レビュー

新機能・フック・スクリプトを実装したら、以下の観点で懸念点を洗い出し、該当するものはIssue化する:

| 観点 | チェック項目 |
| ---- | ------------ |
| **並行性** | 複数セッション/プロセスが同時実行したら？ファイルロックは必要？ |
| **エッジケース** | 空入力、巨大データ、不正形式、タイムアウト時の動作は？ |
| **依存関係** | 外部コマンド（gh, git）が失敗したら？ネットワーク断は？ |
| **状態管理** | ファイル/DBの整合性は？クリーンアップは自動？ |
| **セキュリティ** | 入力のサニタイズは？秘密情報の露出リスクは？ |
| **拡張性** | 将来の変更に対応しやすい設計か？ハードコードはないか？ |

**タイミング**: PR作成前、またはマージ直後に実施

**出力**: 懸念点があればIssueを作成（「将来の改善」としてラベル付け）

### Issueのクローズ方法

GitHubの組み込み機能を使い分ける（ラベルではなく）:

| Close理由 | 用途 |
| --------- | ---- |
| **Completed** | 解決済み、対応完了 |
| **Not planned** | 対応しない、キャンセル、着手前に中止 |
| **Duplicate** | 他のIssueと重複（重複先を指定） |

**操作**: 「Close issue」ボタン横の▼から選択

### Sub-Issueの活用

3つ以上の独立したPRが必要になりそうな場合、sub-issueで親子関係を作成する。

操作方法の詳細は `development-workflow` Skillを参照。

### ブロック後の対応

フックによるブロック後も、**テキストのみの応答で終わらず、必ずツール呼び出しを続ける**。

| 状況 | ❌ 悪い例 | ✅ 良い例 |
| ---- | --------- | --------- |
| worktree削除がブロックされた | 「cwdが中にあるためブロックされました」と説明して終了 | 説明後、`cd /main/repo` を実行してから再試行 |
| マージがブロックされた | 「レビュー未完了です」と説明して終了 | 説明後、`gh pr view` でレビュー状況を確認 |
| 編集がブロックされた | 「mainでは編集できません」と説明して終了 | 説明後、worktreeを作成して移動 |

**理由**: Claude Codeのエージェントループは `while(tool_call)` 構造。テキストのみの応答はループを停止させ、ユーザー入力待ちになる。

**原則**: ブロックは「やり方を変えろ」という指示。停止ではなく、代替アクションを実行する。

#### 重要: ブロック時の根本原因解消

ブロックされた場合、**メッセージを必ず読み、根本原因を解消してから再試行**する。

| ❌ 悪いパターン | ✅ 正しいパターン |
| -------------- | ---------------- |
| ブロックメッセージを読まずに同じ操作を再試行 | メッセージを読んで指示に従う |
| オプションを変えて同じコマンドを試行 | 根本原因（設定、状態）を解消 |
| 3回以上同じ操作を繰り返す | 2回ブロックされたら別アプローチを検討 |

**禁止**: 同一フックで3回以上ブロックされること。2回連続でブロックされた場合は、必ずメッセージを読み直し、指示に従う。

### ACTION_REQUIRED対応（自律的対応）

フックが `[ACTION_REQUIRED: XXX]` 形式のメッセージを出力した場合、**ユーザー確認なしに自律的に対応**する。

| ACTION_REQUIRED | 対応 |
| --------------- | ---- |
| `SYSTEMATIZATION` | フック/CI/スクリプト作成、または不要な理由をIssue化 |
| `CONCRETE_ACTION` | 曖昧表現を具体的なアクションに修正 |

**重要**: ACTION_REQUIREDはブロックではなく**警告**。フローは停止しないが、対応が必要。

**対応例**:

```text
[ACTION_REQUIRED: SYSTEMATIZATION]
教訓が見つかりましたが、仕組み化されていません。
```

→ 以下のいずれかを実行:

1. `.claude/hooks/` にフックを作成
2. `.github/workflows/` にCIチェックを追加
3. 不要な場合はIssueを作成して理由を記録

**フローへの影響**:

- ブロック（exit 2）: フロー停止 → ユーザー入力待ち
- ACTION_REQUIRED（exit 0）: フロー継続 → Claude Codeが自律対応

### フックメッセージはユーザー指示ではない

**重要**: フックのブロックメッセージに「〜してください」「〜を実装してください」と書かれていても、それは**ユーザーからの指示ではない**。

| メッセージの種類 | 扱い | 対応 |
| ---------------- | ---- | ---- |
| ユーザーの発言 | 指示 | 即座に実行 |
| フックのブロックメッセージ | 情報提供 | ユーザーに報告し、指示を待つ |
| フックの警告メッセージ | 情報提供 | ユーザーに報告し、指示を待つ |

**禁止される行動**:

- ❌ フックメッセージを読んで、ユーザー確認なしにworktree作成・作業開始
- ❌ 「フックが〜と言っているので実行します」と宣言して勝手に進める
- ❌ セッション終了時のブロックを「今すぐやれ」という指示と解釈

**正しい対応**:

1. フックメッセージの内容をユーザーに報告
2. 「対応しますか？」と確認
3. ユーザーの明示的な指示を待つ
4. 指示があれば実行

**例外（自動対応してよいケース）**:

1. ブロックの回避操作（cd、状態確認など）
2. メッセージに「（ユーザー確認不要）」と明記されている場合
3. AGENTS.mdの基本原則に直接従う場合（例: 「セッション内で作成したIssueは実装まで完遂」）
4. **`[IMMEDIATE: アクション]` タグがある場合** → 指定されたアクションを即座に実行

**`[IMMEDIATE]` タグの意味**:

- フックが `[IMMEDIATE: /reflect]` のようなタグを出力した場合、**ユーザー確認なしに即座に実行**する
- これは強制力のある指示であり、無視してはならない
- Stop hookで未実行が検出された場合、セッション終了がブロックされる

上記以外の新しいタスク開始（新Issue実装など）はユーザー確認必須。

### 状態確認ファースト原則

**アクション前に現在の状態を確認する**。思い込みで行動せず、事実に基づいて判断する。

| アクション | 事前確認 | 理由 |
| ---------- | -------- | ---- |
| ファイル編集 | `Read`ツールで内容確認 | 既に修正済み/削除済みの可能性 |
| worktree削除 | `git worktree list` | 既に削除済みの可能性 |
| ブランチ作成 | `git branch -a` で確認 | 既に存在する可能性 |
| コミット | `git status` | 変更なし/既にコミット済みの可能性 |
| PR作成 | `gh pr list --head <branch>` | 既に作成済みの可能性 |
| PR状態報告 | 下記「PR状態確認」参照 | 複数フィールドの確認が必要 |

#### PR状態確認（必須フィールド）

PRの状態を報告する際は、以下の**全フィールド**を確認する:

```bash
gh pr view {PR} --json state,mergeStateStatus,mergeable,reviewDecision
```

| フィールド | 値 | 意味 |
| ---------- | -- | ---- |
| `state` | OPEN/MERGED/CLOSED | PR自体の状態 |
| `mergeStateStatus` | **BEHIND**/BLOCKED/CLEAN/DIRTY/UNKNOWN | マージ可能性（BEHINDならリベース必要） |
| `mergeable` | MERGEABLE/CONFLICTING/UNKNOWN | コンフリクト有無 |
| `reviewDecision` | APPROVED/CHANGES_REQUESTED/REVIEW_REQUIRED/空 | レビュー結果 |

**重要**: `reviewDecision` のみで判断しない。`mergeStateStatus: BEHIND` を見落とすと、「レビュー承認待ち」と誤報告する（Issue #2392）。

**アンチパターン**:

- ❌ 「先程やったから次はこれ」と前提で進む
- ❌ エラー/ブロック後に同じコマンドを再試行
- ❌ セッション外の変更を考慮しない

**正しいパターン**:

- ✅ アクション前に常に現状確認
- ✅ ブロック後は状態を再確認してから次のアクション
- ✅ 「既に完了している可能性」を常に念頭に置く

**例**: worktree削除がブロックされた場合

```bash
# ❌ 悪い例: 即座に再試行
git worktree remove .worktrees/issue-123  # ブロック
git worktree remove .worktrees/issue-123  # また同じことを試す

# ✅ 良い例: 状態確認してから判断
git worktree remove .worktrees/issue-123  # ブロック
git worktree list                          # 現状確認
# → 削除済みなら何もしない
# → 存在するなら原因を調べて対処
```

### エラー時の行動指針

**同じエラーを繰り返さない**。エラー発生時は根本原因を分析し、別のアプローチを試す。

| 状況 | 対応 |
| ---- | ---- |
| 同じエラーが2回連続 | エラーメッセージを分析し、別アプローチを試す |
| コマンドが見つからない | `which`で確認、代替ツールを検討 |
| 権限・設定エラー | 設定ファイルを確認、環境を調査 |
| オプション違いで同じエラー | オプションではなく根本原因を解決 |

**禁止**: 同じコマンドを3回以上試行すること

**例**: `uv run ruff`でエラーが発生した場合

```bash
# ❌ 悪い例: オプションを変えて同じパターンを繰り返し
uv run ruff format file.py                    # エラー: No [project] table
uv run --project .claude ruff format file.py  # エラー: No [project] table
uv run --directory .claude ruff format file.py # エラー: No [project] table

# ✅ 良い例: エラーメッセージを分析し、別アプローチを試す
uv run ruff format file.py           # エラー: No [project] table
# → エラーを分析: pyproject.tomlに[project]がない
# → 別アプローチ: uvxを使用（[project]不要）
uvx ruff format file.py              # 成功
```

**エラー分析のポイント**:

1. エラーメッセージを**正確に読む**（「No [project] table」→ [project]が問題）
2. 何が要求されているか理解する（uv run は [project] を必要とする）
3. その要求を満たすか、要求しない別ツールを使う

### 選択肢提示時のルール

複数の選択肢がある場合は、テキストで列挙せず**AskUserQuestionツール**を使用する。

| ❌ 悪い例 | ✅ 良い例 |
| -------- | -------- |
| 「A案、B案、C案があります。どれにしますか？」 | AskUserQuestion で選択肢を提示 |

**例**:

```json
{
  "questions": [{
    "question": "どの方式で実装しますか？",
    "header": "実装方式",
    "options": [
      {"label": "A案: シンプル", "description": "最小限の実装"},
      {"label": "B案: 拡張性重視", "description": "将来の変更に対応"}
    ],
    "multiSelect": false
  }]
}
```

**例外**:

- 選択肢が1つで推奨案のみ → テキストで提示可

## プロジェクト概要

dekita! - ハンズオン・ワークショップ向けのリアルタイム進捗共有ツール

**本番URL**: <https://dekita.app/>

**構成**:

- `frontend/` - React + TanStack Router (Vite)
- `worker/` - Cloudflare Workers + Hono
- `shared/` - 共通の型定義

## 環境情報

| 環境 | Frontend | API |
| ---- | -------- | --- |
| 本番 | <https://dekita.app> | <https://api.dekita.app> |
| プレビュー | PR毎に生成 | PR毎に生成 |
| ローカル | 起動時のログを確認 | 起動時のログを確認 |

## コマンド

| 用途 | コマンド |
| ---- | -------- |
| ビルド | `pnpm build` |
| テスト | `pnpm test:ci` |
| Lint | `pnpm lint` |
| 型チェック | `pnpm typecheck` |

### Pythonツール

| 用途 | コマンド | 備考 |
| ---- | -------- | ---- |
| ruff format | `uvx ruff format <file>` | 一時環境で実行（インストール不要） |
| ruff check | `uvx ruff check <file>` | 一時環境で実行（インストール不要） |
| pytest | `uv run pytest <path>` | 仮想環境内で実行 |

**注**: `uv run pytest` は `pyproject.toml` の `[dependency-groups].dev` で管理されたpytestを使用

### CI監視

PRのCI監視には`ci_monitor.py`を使用する（依存関係は`pyproject.toml`で管理）。

| ❌ 禁止 | ✅ 推奨 |
| ------- | ------- |
| `gh pr checks --watch` | `python3 .claude/scripts/ci_monitor.py <PR番号> --session-id <SESSION_ID>` |

※ `<SESSION_ID>`はUserPromptSubmit hookで提供されるセッションID（UUID形式）

**例**: `python3 .claude/scripts/ci_monitor.py 1234 --session-id 3f03a042-a9ef-44a2-839a-d17badc44b0a`

**重要**: `--session-id`を省略するとppidフォールバックが発動し、ログが正しいセッションと紐付かなくなる

**ci_monitor.pyの利点**:

- BEHIND検知 → 自動リベース
- レビュー完了検知 → コメント取得
- CI失敗 → 即座に通知

### プラグイン

Claude Code公式プラグインを活用する。

| プラグイン | 用途 | 使用タイミング |
| ---------- | ---- | -------------- |
| `code-simplifier` | AI特有のコード肥大化を防止 | 長時間セッション後、PR作成前 |

**インストール**: `claude plugin install <プラグイン名>`

**プラグイン追加時の対応**:

1. このセクションにプラグインを追記
2. 使用タイミングを `development-workflow` Skillに追記
3. 必要に応じてフックで強制（例: PR作成前に `/simplify` 実行を推奨）

## コスト方針

- **実装コスト**: 度外視OK
- **運用コスト**: 最小化（Cloudflare Free tier活用）

## セキュリティポリシー

- 非公式GitHub Actionsの導入禁止（例外: Astral公式アクション `astral-sh/*` は許可）
- 外部ツール提案前にセキュリティリスクを評価
- Dependabot PRではE2Eテスト自動実行しない（Pwn Request攻撃対策）

## ドキュメント更新

以下の変更時は対応ドキュメントの更新を確認:

| 変更内容 | 更新対象 |
| -------- | -------- |
| ユーザーデータ収集、外部サービス追加 | プライバシーポリシー |
| 主要機能の追加・削除 | 利用規約、FAQ |
| 環境構築関連 | README.md |
| 開発フロー、コーディング規約 | AGENTS.md / Skills |

**更新基準**:

- **AGENTS.md**: プロジェクト全体の方針、基本原則、例外事項
- **Skills**: 実際の手順、ワークフロー、詳細な作業フロー

**重要**: `privacy`/`terms`セクションは**ja.jsonのみ**に記載（CIで自動チェック）

---

## Skills

Claudeがコンテキストに基づいて自動で発見・使用する詳細手順。

| Skill | 用途 |
| ----- | ---- |
| `reflect` | セッション振り返り、五省、なぜなぜ分析 |
| `reflect-trends` | 直近3日間の傾向分析（fix比率、ブロックパターン） |
| `development-workflow` | Worktree、PR作成、CI監視、マージ |
| `code-review` | AIレビュー確認、コメント対応、Resolve |
| `coding-standards` | コーディング規約、テスト、Lint |
| `hooks-reference` | フック詳細仕様、設計原則 |
| `troubleshooting` | エラー、問題発生時の解決策 |
| `add-perspective` | 振り返り観点の追加 |
| `claude-code-features` | Claude Code機能調査・提案 |

**トリガー例**:

- `/reflect` → セッション終了時の振り返り
- `/reflect-trends` → 複数セッションの傾向分析
- 「PRを作成したい」→ `development-workflow`
- 「レビューコメントを確認」→ `code-review`
- フック修正・実装 → `hooks-reference`
- 「エラーが出る」「動かない」→ `troubleshooting`

> **補足**: 複数のSkillが該当する場合、Claudeがコンテキストから最適なSkillを選択。必要に応じて複数Skillを組み合わせて対応。

### Skill使用の判断基準

**重要**: 「単純かどうか」ではなく「該当する作業かどうか」でSkill使用を判断する。

| ❌ 誤った判断 | ✅ 正しい判断 |
| ------------ | ------------ |
| 「単純な実装だからSkill不要」 | 「フック修正だからhooks-reference参照」 |
| 「小さな変更だからSkill不要」 | 「PR作成だからdevelopment-workflow参照」 |

**理由**: 既存の実装パターンを見落とし、レビューで指摘されるリスクを回避するため。

---

## Review guidelines

AIコードレビュー（Gemini, Codex, Copilot等）向けの品質基準。

### 優先度定義

| 優先度 | 対象 | 例 |
| ------ | ---- | -- |
| **P0** | 即座に修正必須 | セキュリティ脆弱性、データ破損、本番障害 |
| **P1** | マージ前に修正 | バグ、設計問題、パフォーマンス劣化、テスト不足 |
| **P2** | 改善推奨 | コードスタイル、ドキュメント、リファクタリング |

### 設計品質チェック（P1）

以下の設計原則違反は **P1** として報告する:

#### 結合度（Coupling）

**低結合を維持する**。モジュール間の依存を最小限に。

| 問題パターン | 説明 |
| ------------ | ---- |
| 神クラス/神関数 | 1つのモジュールが多くの責務を持ち、多数の外部依存がある |
| 循環依存 | A→B→C→A のような循環参照 |
| 具象依存 | インターフェースではなく具体的な実装に依存 |
| グローバル状態 | 複数モジュールが共有するグローバル変数 |
| 密結合 | 内部実装の詳細に依存（private メソッドの直接呼び出し等） |

#### 凝集度（Cohesion）

**高凝集を維持する**。関連する機能を1つのモジュールにまとめる。

| 問題パターン | 説明 |
| ------------ | ---- |
| 偶発的凝集 | 関連のない機能が同じモジュールに存在 |
| 論理的凝集 | 似た処理だが異なる目的の機能が混在 |
| 散在する機能 | 1つの機能が複数モジュールに分散 |
| ユーティリティ肥大化 | `utils.ts` に無関係な関数が集積 |

#### 単一責任原則（SRP）

- 1つのモジュール/クラス/関数は1つの責務のみを持つ
- 「この変更理由は1つか？」で判断
- 複数の理由で変更される場合は分割を検討

#### 変更影響範囲

- PRの変更が関連しないファイルに波及していないか
- 1つの変更が多数のファイルを修正する場合は設計を見直す

### セキュリティチェック（P0/P1）

以下は必ず報告する:

- 認証・認可の欠如または不備
- 入力値の検証不足（SQLインジェクション、XSS等）
- 秘密情報のハードコード
- 安全でない暗号化・ハッシュ

### テストカバレッジ（P1）

- 新規コードにテストがあるか
- エッジケース（空入力、境界値、エラー）がテストされているか
- モックが適切に使用されているか

### このプロジェクト固有のルール（P1）

- `console.log` は開発環境のみ（`import.meta.env.DEV` でガード）
- Sentryの `setTag`/`setContext` はグローバルスコープ禁止（`withScope` 使用）
- 型の `any` 使用は原則禁止（やむを得ない場合はコメント必須）
- i18n翻訳は `ja.json` のみに記載

### 修正漏れチェック（P1）

共通パターン（関数、定数、設定値）を変更するPRでは、以下を確認:

- [ ] 同様のパターンが他のファイルに存在しないか？（`rg "パターン"` で確認）
- [ ] 全ての呼び出し箇所が修正されているか？
- [ ] 修正漏れがある場合はP1として報告

**背景**: #2054 で `json.dumps` の修正時に2箇所の漏れがあり、#2065 で再修正が必要になった。

### パターンマッチング実装（P1）

正規表現によるパターンマッチングを実装する際は以下を確認:

| チェック項目 | 説明 |
| ------------ | ---- |
| **複数条件の組み合わせ** | 「成功条件の存在」を積極的に確認し、「失敗条件の不在」のみで成功と判断しない |
| **フラグの一貫性** | `re.IGNORECASE` 等のフラグは全ての検索で統一する |
| **テストのリアリティ** | 実際の出力を模倣（stdout/stderr両方を考慮） |

**背景**: #2099 でブランチ削除失敗パターンのみでマージ成功と判定し、誤検知が発生。#2101 で修正。

### AIレビュー間の矛盾時の対応（P1）

複数のAIレビュー（Copilot、Gemini、Codex等）の結果が矛盾する場合の対応方針。

| 状況 | 対応 |
| ---- | ---- |
| Copilot「問題なし」+ Gemini「問題あり」 | **Geminiの指摘を優先**。Issue作成必須 |
| 複数AIが異なる指摘 | 全ての指摘を検討し、妥当なものは対応 |
| セキュリティ関連の指摘 | **必ずIssue化**。「問題なし」で無視しない |

**原則**:

1. **「問題なし」は採用しない**: あるAIが「問題なし」としても、別のAIの指摘を無視しない
2. **セキュリティ指摘は最優先**: medium以上のセキュリティ指摘は必ずIssue化
3. **統合判断**: 複数AIの結果を統合し、最も保守的な判断を採用

**背景**: PR #2702 でCopilotは「問題なし」としたが、Geminiは2つのReDoS脆弱性を指摘。Issueが作成されずにマージされ、セキュリティ問題が本番に入った（Issue #2709）。

---

## 関連ドキュメント

- `frontend/src/routes/privacy.tsx` - プライバシーページ
- `frontend/src/routes/terms.tsx` - 利用規約ページ
- `frontend/src/routes/faq.tsx` - FAQページ
