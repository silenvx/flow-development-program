#!/usr/bin/env python3
"""操作成功時に動作確認Issueのチェック項目を自動更新する。

Why:
    作業中に自然と実行される操作（ビルド、テスト等）で動作確認を
    自動検証することで、まとめテストの負担を軽減する。

What:
    - ツール実行成功を検出（Bash exit 0、Read成功等）
    - 対応する動作確認項目を特定
    - observation Issueのチェック項目を自動更新
    - 全Claude確認項目チェック時はIssueを自動クローズ

Remarks:
    - 自動化型フック（ブロックしない、Issue自動更新）
    - PostToolUse:Bash/Readで発火
    - post-merge-observation-issue.pyがIssue作成（補完関係）
    - 人間確認項目（UI表示、モバイル等）は自動チェック対象外

Changelog:
    - silenvx/dekita#2595: フック追加
"""

import json
import re
import subprocess

from lib.constants import TIMEOUT_LIGHT, TIMEOUT_MEDIUM
from lib.execution import log_hook_execution
from lib.github import get_observation_issues
from lib.hook_input import get_exit_code, get_tool_result
from lib.session import parse_hook_input

# Mapping from operation pattern to checklist item text
# Each entry: (tool_name, command_pattern, checklist_item_pattern)
# NOTE: checklist_item_pattern must be literal strings (no regex tokens like .*)
#       because update_checklist_item uses re.escape for safety
#
# The patterns here correspond to checklist items generated by
# post-merge-observation-issue.py's FILE_CHECKLIST_PATTERNS.
#
# NOT MAPPED (require manual verification or are hard to auto-detect):
# - "エラーハンドリングが正しく動作する" - requires exception injection
# - "エラーレスポンスが適切に返る" - requires error scenario testing
OPERATION_TO_CHECKLIST: list[tuple[str, str, str]] = [
    # Hook execution log verification (.claude/hooks/ pattern)
    # Detects: cat .claude/logs/execution/hook-execution-*.jsonl | grep <hook>
    # or: grep <hook> .claude/logs/execution/hook-execution-*.jsonl
    (
        "Bash",
        r"(grep|cat).*.claude/logs/execution/hook-execution.*\.jsonl",
        "フックが正しく発火する",
    ),
    # TypeScript/JavaScript build (frontend/src/ pattern)
    ("Bash", r"pnpm\s+build|npm\s+run\s+build", "ビルドが成功する（`pnpm build`）"),
    # TypeScript/JavaScript tests (.test. pattern)
    ("Bash", r"pnpm\s+test|npm\s+test|pnpm\s+test:ci", "テストが全てパスする（`pnpm test:ci`）"),
    # Type check (shared/ pattern)
    ("Bash", r"pnpm\s+typecheck", "型定義の変更がfrontend/workerで正しく反映される"),
    # Script execution with --help (.claude/scripts/ pattern)
    ("Bash", r"python3?\s+.*\.py\s+--help", "ヘルプオプション（--help）が動作する"),
    # Script execution (.claude/scripts/ pattern)
    ("Bash", r"\.claude/scripts/.*\.py\b", "スクリプトが正常に実行できる"),
    # API health check (worker/src/ pattern)
    ("Bash", r"curl.*?api\.dekita\.app/health", "APIが正常にレスポンスを返す"),
    # GitHub Actions run check
    ("Bash", r"gh\s+run\s+list", "CIが正常に動作する"),
    # Settings verification (any successful read/edit of settings.json)
    ("Read", r"settings\.json", "設定変更が反映される"),
]

# Human verification items - these should NOT be auto-checked
# These items are excluded from auto-check and auto-close conditions.
# They require manual verification or are hard to auto-detect.
HUMAN_ITEMS_PATTERNS = [
    "UI表示",
    "モバイル表示",
    "アクセシビリティ",
    "体感確認",
    "実機",
    "目視",
    # Error handling requires exception injection, hard to auto-detect
    "エラーハンドリング",
    "エラーレスポンス",
]


def is_human_item(item: str) -> bool:
    """Check if the checklist item requires human verification."""
    for pattern in HUMAN_ITEMS_PATTERNS:
        if pattern in item:
            return True
    return False


def find_matching_checklist_item(tool_name: str, command_or_path: str) -> str | None:
    """Find the checklist item that matches the operation.

    Args:
        tool_name: The tool that was used (e.g., "Bash", "Read")
        command_or_path: The command or file path used

    Returns:
        The checklist item pattern if found, None otherwise
    """
    for expected_tool, pattern, checklist_item in OPERATION_TO_CHECKLIST:
        if tool_name != expected_tool:
            continue
        if re.search(pattern, command_or_path, re.IGNORECASE):
            return checklist_item
    return None


def get_issue_body(issue_number: int) -> str | None:
    """Get the body of an issue."""
    try:
        result = subprocess.run(
            ["gh", "issue", "view", str(issue_number), "--json", "body"],
            capture_output=True,
            text=True,
            timeout=TIMEOUT_LIGHT,
        )
        if result.returncode != 0:
            return None
        data = json.loads(result.stdout)
        return data.get("body", "")
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        return None


def update_checklist_item(body: str, item_pattern: str) -> tuple[bool, str]:
    """Update a checklist item from unchecked to checked.

    Args:
        body: Current issue body
        item_pattern: Pattern to match the checklist item

    Returns:
        Tuple of (success, updated_body)
    """
    # Find unchecked item matching the pattern
    # Pattern: "- [ ] <item text containing pattern>"
    unchecked_pattern = rf"(- \[ \] )([^\n]*{re.escape(item_pattern)}[^\n]*)"
    match = re.search(unchecked_pattern, body, re.IGNORECASE)

    if not match:
        # Item not found or already checked
        return False, body

    # Replace with checked version
    full_match = match.group(0)
    checked_version = full_match.replace("- [ ] ", "- [x] ", 1)
    updated_body = body.replace(full_match, checked_version, 1)

    return True, updated_body


def count_claude_items(body: str) -> tuple[int, int]:
    """Count total and checked Claude Code verification items.

    Returns:
        Tuple of (total_items, checked_items)
    """
    # Find the Claude Code verification section
    claude_section_match = re.search(
        r"## Claude Code確認項目\n+((?:- \[[ x]\] [^\n]+\n?)+)",
        body,
        re.MULTILINE,
    )

    if not claude_section_match:
        return 0, 0

    section = claude_section_match.group(1)

    # Count items
    total = len(re.findall(r"- \[[ x]\] ", section))
    checked = len(re.findall(r"- \[x\] ", section))

    return total, checked


def update_issue_body(issue_number: int, new_body: str) -> bool:
    """Update the issue body via GitHub API."""
    try:
        result = subprocess.run(
            ["gh", "issue", "edit", str(issue_number), "--body", new_body],
            capture_output=True,
            text=True,
            timeout=TIMEOUT_MEDIUM,
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


def close_issue(issue_number: int) -> bool:
    """Close the issue as completed."""
    try:
        result = subprocess.run(
            ["gh", "issue", "close", str(issue_number), "--reason", "completed"],
            capture_output=True,
            text=True,
            timeout=TIMEOUT_LIGHT,
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


def process_observation_issues(
    checklist_pattern: str,
) -> list[tuple[int, bool]]:
    """Find and update observation issues with matching checklist items.

    Args:
        checklist_pattern: The pattern to match in checklist items

    Returns:
        List of (issue_number, was_closed) tuples for issues that were updated
    """
    updated_issues: list[tuple[int, bool]] = []

    # Get open observation issues
    issues = get_observation_issues(limit=50, fields=["number", "title"])

    for issue in issues:
        issue_number = issue.get("number")
        if not issue_number:
            continue

        # Get issue body
        body = get_issue_body(issue_number)
        if not body:
            continue

        # Check if this pattern exists as unchecked item
        success, updated_body = update_checklist_item(body, checklist_pattern)

        if not success:
            continue

        # Update the issue body
        if not update_issue_body(issue_number, updated_body):
            continue

        # Check if all claude items are now checked
        total, checked = count_claude_items(updated_body)
        should_close = total > 0 and total == checked

        if should_close:
            close_issue(issue_number)

        updated_issues.append((issue_number, should_close))

    return updated_issues


def main() -> None:
    """Main hook logic."""
    input_data = parse_hook_input()
    if not input_data:
        return

    tool_name = input_data.get("tool_name", "")

    # Get command or file path based on tool type
    tool_input = input_data.get("tool_input", {})
    command_or_path = ""

    if tool_name == "Bash":
        command_or_path = tool_input.get("command", "")
    elif tool_name == "Read":
        command_or_path = tool_input.get("file_path", "")
    else:
        # Only process Bash and Read for now
        return

    if not command_or_path:
        return

    # Check if operation succeeded
    tool_result = get_tool_result(input_data)
    if not tool_result:
        # No result available, skip
        return

    exit_code = get_exit_code(tool_result)

    # For Bash, require exit code 0
    if tool_name == "Bash" and exit_code != 0:
        return

    # For Read, check for errors
    if tool_name == "Read" and tool_result.get("is_error"):
        return

    # Find matching checklist item
    checklist_pattern = find_matching_checklist_item(tool_name, command_or_path)
    if not checklist_pattern:
        return

    # Process observation issues
    updated = process_observation_issues(checklist_pattern)

    if updated:
        for issue_number, was_closed in updated:
            if was_closed:
                print(
                    f"\n[observation-auto-check] 動作確認Issue #{issue_number} を"
                    f"自動クローズしました（全項目チェック完了）"
                )
                log_hook_execution(
                    "observation-auto-check",
                    "approve",
                    f"auto-closed issue #{issue_number} (all items checked)",
                )
            else:
                print(
                    f"\n[observation-auto-check] Issue #{issue_number} の"
                    f"「{checklist_pattern}」をチェックしました"
                )
                log_hook_execution(
                    "observation-auto-check",
                    "approve",
                    f"checked '{checklist_pattern}' in issue #{issue_number}",
                )


if __name__ == "__main__":
    main()
