# 既知の誤検知パターン

AIレビューで発生した誤検知パターンを記録する。同様のパターンが検出された場合、参照して適切に対応する。

## ドキュメント内のコード例を誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #1651 | 「関数名が存在しません」 | ドキュメント内のコード例で使用された `print_continue_and_log_skip` を誤検知。実際には `.claude/hooks/common.py` に定義されている正しい関数名 |

**対応**: False positiveとして却下（修正不要）

**回避策**: ドキュメント内のコード例に対する「存在しない」系の指摘は、実際のコードベースで関数が定義されているか確認してから判断する。

## 静的解析の誤検知（dict is unhashable）

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #1762 | 「dict is unhashable」 | `flow_def = definitions[flow_id]` のような辞書アクセスで、dict がキーとして使われていると誤認。実際は `flow_id`（文字列）がキー |

**対応**: False positiveとして却下（修正不要）

**回避策**: 「unhashable」系の静的解析警告は、実際に dict/list をキーとして使用しているか確認する。変数名やコンテキストから誤検知を判断できることが多い。

## ラッパー関数の引数順序スワップを誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #2512 | 「Incorrect argument order」 | ラッパー関数で意図的に引数順序を変更している場合、AIレビューが「引数順序が間違っている」と誤検知。コメントで説明済みでも検出される |

**対応**: False positiveとして却下（修正不要）

**回避策**: ラッパー関数で引数順序を変更する場合、コードコメントで明示的に説明する。AIレビューが同様の指摘をした場合は、コメントを確認して誤検知と判断する。

## 異なる目的の関数間のパラメータ差異を誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #2512 | 「Inconsistent parameter ordering」 | 異なる目的を持つ関連関数（例: `record_block` と `check_block_resolution`）のパラメータが異なることを「inconsistent」と誤認識 |

**対応**: False positiveとして却下（修正不要）

**回避策**: 関連する関数でパラメータセットが異なる場合、その理由（目的の違い）をdocstringで説明する。`record_block`は`reason`が必要（ブロック理由を記録）、`check_block_resolution`は`reason`不要（解決チェックのみ）のように、目的に応じたパラメータ差異は正しい設計。

## JSONLファイルにJSON配列対応を求める指摘

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #2725 | 「Handle JSON-array transcripts」 | JSONL形式（.jsonl、1行1JSON）のファイルを処理するコードに対し、「JSON配列形式にも対応すべき」と指摘。Claude Codeのトランスクリプトは常にJSONL形式で保存されるため不要 |

**対応**: False positiveとして却下（修正不要）

**回避策**: JSONL形式のファイル処理では、ファイル拡張子（.jsonl）と用途（Claude Codeトランスクリプト）を確認する。`lib.transcript.load_transcript`のような別ライブラリがJSON配列をサポートしていても、直接ファイルを読む場合はJSONL前提で問題ない。

## リファクタリング後のインポート「未使用」誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #2962 | 「未使用インポート」 | リファクタリングで特定関数からインポートを使わなくなったが、同一ファイル内の他の関数では引き続き使用されている場合に「未使用」と誤検知 |

**対応**: False positiveとして却下（修正不要）

**回避策**: インポートの「未使用」指摘を受けた場合、ファイル全体を検索（Grepツール）して、他の箇所で使用されているか確認する。変更した関数以外で使用されている場合は誤検知。

## 意図的なearly return/false returnを誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3107 | 「テスト期待値が間違っている」 | `isCommandWithCommentContent`がチェーンされたghコマンド（`&&`や`;`で連結）に対して意図的に`false`を返す仕様を見落とし、`true`を返すべきと誤指摘 |

**対応**: False positiveとして却下（修正不要）

**回避策**: 関数内に「意図的にこの条件でfalse/trueを返す」というコメントがある場合、その意図を確認する。テストの期待値が「間違っている」という指摘を受けたら、実装のコメントを確認し、意図的な設計かどうかを判断する。

## 正規表現がエスケープを処理しないという誤判定

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3112 | 「正規表現がエスケープを処理しない」 | `extractPrBody`の正規表現が `"Test \"quoted\""` のようなエスケープされたクォートを処理できないと誤判定。実際は `([^"\\\\]*(?:\\\\.[^"\\\\]*)*)` パターンでエスケープを正しく処理している |

**対応**: False positiveとして却下（修正不要）

**回避策**: 正規表現に `([^"\\\\]*(?:\\\\.[^"\\\\]*)*)` のようなエスケープ処理パターンが含まれている場合、エスケープは正しく処理されている。AIレビューが「エスケープを処理しない」と指摘した場合は、実際にテストを実行して動作を確認する。

## Pythonの暗黙的文字列連結を誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3183 | 「Missing comma between elements」 | 複数行にわたる長いjq式を隣接する文字列リテラルで記述した際、リスト要素間のカンマ欠落と誤検知。Pythonの暗黙的文字列連結は正しい文法 |

**対応**: False positiveとして却下（修正不要）

**回避策**: Pythonでは隣接する文字列リテラル（`"abc" "def"`）は自動連結される。「カンマがない」指摘を受けた場合は、リスト/タプル要素か暗黙的連結かを確認する。

## gh api --jq出力形式の誤認

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3183 | 「gh api --jq outputs pretty-printed JSON」 | `gh api --jq '.[] | {...}'`の出力がpretty-print（複数行整形）されると誤認。実際は1行JSONを出力する |

**対応**: False positiveとして却下（修正不要）

**回避策**: `gh api --jq`の出力形式はjq式に依存する。`.[] | {...}`のようなフィルタ式はコンパクトな1行JSONを出力する。「pretty-print対応が必要」と指摘された場合は、実際のコマンド出力を確認する。

## gh api -F フラグの型変換を誤認

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3200 | 「gh api -F flag passes strings」 | `-F` フラグは整数を自動的にJSON整数型に変換する。Geminiが「-f を使え」と提案するが、逆に `-f` は常に文字列として渡すため不適切 |

**対応**: False positiveとして却下（修正不要）

**回避策**: `gh api --help` より「`-F/--field` flag has magic type conversion based on the format of the value: literal values `true`, `false`, `null`, and integer numbers get converted to appropriate JSON types」。整数型が必要な場合は `-F` を使用するのが正しい。

## 日本語文字列のスペース誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3255 | 「日本語にスペースがある」 | Geminiがエンコーディング問題で日本語文字列にスペースがあると誤認識。実際のコードで確認して判断 |
| PR #3508 | 「使用」「特にこの」にスペース | 同一PRで3回のレビュー（初回、リベース後、順序変更後）全てで同じ誤検知が繰り返された。`od -c`で検証した結果、実際にはスペースは存在しない |

**対応**: False positiveとして却下（修正不要）

**回避策**: AIレビューが「日本語文字列にスペースがある」と指摘した場合は、実際のソースコードを確認する。Geminiがトークン化やエンコーディングの問題で日本語文字を誤認識している可能性がある。

**検証コマンド**:
```bash
# 該当行を抽出し、od -c で文字を確認（スペースは空白文字として表示される）
sed -n '<行番号>p' <ファイル> | od -c
# 例: sed -n '59p' file.md | od -c
# 日本語文字間にスペース（空白）がないことを目視確認
```

**特徴**: この誤検知は同一コミットでも繰り返し発生する（リベース後も同じ指摘）。一度検証して誤検知と確認した場合、以降の同じ指摘は無視して問題ない。

## includes()の部分文字列マッチを誤認

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3375 | 「includes()の条件が両方にマッチする可能性」 | `cmd.includes("origin/main...HEAD")` と `cmd === "git diff --name-only HEAD"` の条件で、「両方の文字列が "HEAD" を含むため両方にマッチする可能性がある」と誤指摘。実際は `includes()` は引数の**部分文字列全体**を含むかチェックするため、短い単語が共通していても長い部分文字列全体を含まなければマッチしない |

**対応**: False positiveとして却下（修正不要）

**回避策**: `includes()` の動作を理解する。`"git diff --name-only HEAD".includes("origin/main...HEAD")` は `false` を返す（"origin/main...HEAD" という**連続した部分文字列**が存在しないため）。AIレビューが「両方にマッチする」と指摘した場合は、実際のコードで動作を確認する。

## 条件分岐の設計意図を理解しない

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3523 | 「条件により検知できない」 | ci_monitorのBLOCKED状態検知で `currentAiPending` 条件を使用した際、「AIレビュー完了後に検知できない」と誤指摘。実際は成功ブロック（別の箇所）で処理されており、意図的な設計 |
| PR #3523 | 「フラグリセット条件が不適切」 | `hasLoggedBlockedReason` フラグのリセット条件について「状態変化時に正しくリセットされない」と誤指摘。BLOCKED状態継続中はフラグを保持し、mergeState変化時のみリセットする意図的な設計 |
| PR #3523 | 「冗長なAPI呼び出し」 | 「別の場所で同じAPIを呼び出しているため冗長」と誤指摘。条件分岐により両方が同時に実行されることはなく、意図的に重複を避けた設計 |

**対応**: False positiveとして却下（修正不要）

**回避策**: 条件分岐を含むコードへの指摘を受けた場合、以下を確認・対応する:
1. 他のコードパス（成功ブロック、エラーハンドリング等）で同様の処理が実装されていないか確認する
2. 条件の組み合わせを考慮し、指摘された問題が実際に発生しうるか再検証する
3. コメントで設計意図が説明されているか確認し、不足している場合は追記してAIの誤解を防ぐ

**特徴**: Copilotは個々のコードブロックを分析するが、全体のフロー（条件分岐の排他性、別パスでの処理等）を見落とすことがある。pre-pushレビュー（Codex/Gemini並列）で問題なしと評価されたコードに対してCopilotが誤指摘することがある。

## ディレクトリ構造のパス重複を誤認

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3540 | 「hooks doubled」 | `.claude/hooks/handlers/` というパス構造で、`hooks` が2回出現することを「パスの重複」と誤認。実際は `.claude/hooks/` がフック設定ディレクトリ、その中の `handlers/` がTypeScriptフック実装のディレクトリという正しい構造 |

**対応**: False positiveとして却下（修正不要）

**回避策**: このプロジェクトのフックディレクトリ構造を理解する:
- `.claude/hooks/` - フック設定・スクリプトのルートディレクトリ
- `.claude/hooks/` - TypeScriptフック関連
  - `hooks/` - フック実装ファイル
  - `lib/` - 共通ライブラリ
  - `tests/` - テストファイル
- `.claude/hooks/*.py` - 既存Pythonフック（段階的移行中）

**特徴**: Geminiがパス名の単語重複を検出するが、異なる階層で異なる目的を持つディレクトリ名の重複は設計上正当。

## 再代入される変数を`const`に変更する提案

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3792 | 「`let`を`const`に変更すべき」 | 変数が初期化後に条件分岐内で再代入される場合、AIが初期化時点のみを見て「再代入されていないから`const`を使うべき」と誤指摘 |

**対応**: False positiveとして却下（修正不要）

**回避策**: `let`で宣言された変数への「`const`を使うべき」指摘を受けた場合、変数が後続のコードで再代入されているか確認する。条件分岐（`if`/`else`）内での再代入は、AIが見落とすことがある。

**検証方法**:
```bash
# 該当ファイルで変数名を検索し、再代入箇所を確認
grep -n "<変数名>" <ファイル名>.ts
# 再代入（= resolve(...)等）があれば let が正しい
```

**特徴**: Gemini/Qodoが変数宣言を見て`const`を提案するが、後続のコードブロック（特に条件分岐内）での再代入を見落とす。

## UTF-8日本語ファイルの文字化け誤検知

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #3868 | 「文字化けが含まれています」 | Greptileが正常なUTF-8日本語コメント（`// 応答がある場合のみチェック（空や取得できない場合は状態を維持）`）を「`���得できない場合`」と表示し、文字化けと誤検知 |

**対応**: False positiveとして却下（修正不要）

**回避策**: Greptileが「文字化けが含まれています」と指摘した場合、`file`コマンドでエンコーディングを確認し、`git show HEAD -- <ファイル>`で実際の内容を確認する。

**検証コマンド**:
```bash
# エンコーディング確認
file <ファイルパス>
# → "Unicode text, UTF-8 text" なら正常

# 実際の内容確認
# 指定行のみ表示
git show HEAD -- <ファイルパス> | sed -n '<行番号>p'

# 前後3行も表示（文脈確認用）
git show HEAD -- <ファイルパス> | awk -v line=<行番号> 'NR>=line-3 && NR<=line+3'
```

**特徴**: Greptileのレビューツール側でUTF-8日本語テキストのデコードに問題がある。プロジェクト側の問題ではなく、ツール側の表示問題。

## gh api -p/--paginateフラグの誤認

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #4023 | 「`-p`は値を取らない`--paginate`」 | CodeRabbitが「`-p`は`--paginate`の短縮形」と誤認し、値を取るフラグとして`-p`が`GH_API_VALUE_FLAGS`に含まれている点を指摘。実際は`-p`は`--preview`（プレビューヘッダーを指定、値を取る）の短縮形であり、`--paginate`とは別のフラグ。 |

**対応**: False positiveとして却下（修正不要）

**回避策**: `gh api --help`で確認すると:
- `-p, --preview strings`: Add a `preview` header to indicate that an API endpoint should be accessed in its preview state（値を取る）
- `--paginate`: Make additional HTTP requests to fetch all pages of results（値を取らない、短縮形なし）

`-p`と`--paginate`は別のフラグである。AIレビューが「`-p`は`--paginate`の短縮形」と前提した指摘をした場合は誤検知。

**検証コマンド**:

```bash
gh api --help | grep -E '^[[:space:]]+(-p, --preview|--paginate)'
```

## リファクタリングで削除した行の再追加を提案

| 発生 | パターン | 詳細 |
| ---- | -------- | ---- |
| PR #4094 | 「tests/の除外が必要」 | `hook_change_detector.ts` の66行目（`lib/`除外チェック）を見て「`tests/`の除外が必要」と指摘。実際は63行目に既に`tests/`の除外チェックが存在。Geminiは差分の削除行（旧 `ts/lib/` と `ts/tests/` の除外）を見て、新構造でも同等の除外が必要と誤判断 |

**対応**: False positiveとして却下（修正不要）

**回避策**: リファクタリングで除外パターンを削除した場合、以下を確認する:
1. 削除した除外パターンがカバーしていた範囲が他の除外パターンでカバーされているか確認
2. 新しい除外パターンが既にファイル内に存在するか確認

**検証方法**:
```bash
# 除外パターンの動作を確認（例: tests/が除外されているか）
find <対象ディレクトリ> -type f -name "*.ts" | grep -v "tests/" | head -10

# または、該当コードで除外条件を検索
grep -n "tests" <ファイル名>.ts
```

**特徴**: Geminiは差分（特に削除行）を見て「削除されたものを戻すべき」と提案する傾向がある。リファクタリングで意図的に削除したパターンが、別の行で既にカバーされている場合でも、差分だけを見て誤検知する。
